% dConstruct 2012
% Lyza Gardner
% September 6, 2012

# Part 0: Setting the scene

-------------------------------------------------------------------------------

## This magical web world

> "Be not afeard; the isle is full of noises." —*The Tempest*, Act III, Scene 2, Wm. Shakespeare

## Our Devices

* BlackBerry 8320 Curve v4.5.0.81 (native browser). Our project manager Megan's old phone. Hardware keyboard and pointer.
* BlackBerry 9670 Style v6.0.0.123 (native browser). BlackBerry flip phone.
* Nexus S Android 4.1.1 Firefox 14.0.2. Smart Phone w/touchscreen.
* Nexus S Android 4.1.1 native
* Motorola Backflip Android 1.5 (Motorola Blur Build)
* iPhone 4 iOS 5.1.1 native Safari browser
* iPhone 4 iOS 5.1.1 Opera Mini
* Nokia N8 Windows Phone native browser (version?)
* [Opera Mini simulator](http://www.opera.com/developer/tools/mini/)
* Kindle Fire tablet v6.3 native browser 


-------------------------------------------------------------------------------

# Part 1. Starting from scratch

## Starting with nothing

To set our stage, our scene, our story today, we are going to start from a fresh slate, as if we are building a web project from scratch.

#### Real world moment

The options for truly starting from scratch, with no legacy or history, are limited. But let's pretend we have that luxury.

## So many options

When we start from scratch, we have so many choices to make.

* Web site
* Native application
* Web site that works on mobile devices
* Web site that works "everywhere"
* Web site that works on selected devices
* Web site using development framework or tools
* Adaptation of existing web site

Mobile web development has a complicated and somewhat mysterious history.


## NEED TO FLESH OUT HIGH-LEVEL SLIDES HERE 


## The evolution of mobile markup and options

### WML, XHTML-MP...

* SGML
* HDML (OpenWave) -> WML
* HTML/XHTML
* cHTML (Compact HTML/iMode)
* XHTML-MP 1.1
* XHTML-MP 1.2
* XHTML-Basic

## XHTML-MP

XHTML-MP held sway for a number of years in the 2000's. It provided an HTML-like experience (certainly better than WAP/WML!) tailored to a mobile environment.

### DOCTYPES

~~~
<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN"
"http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
 
<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.1//EN"
"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile11.dtd">
 
<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN"
"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">
~~~

-------------------------------------------------------------------------------

## XHTML-MP, cont.

* Modularized XHTML
* Provided a bridge between simplified (WML) mobile markup and more full-featured support
* DOCTYPE triggers (some) mobile browsers to use different layout modes
* Was commonly used

### Not supported

* `<iframe>`
* `target` attribute in links
* Certain `<table>` tags (`<tbody>`, etc.)
* Plugins

#### Handout

##### References

* Gail Rahn-Frederick and Rajesh Lal's [*Beginning Smartphone Web Development*][rahn-frederick] is a few years old now but has an in-depth look at the history, evolution and specifics of mobile markup and DOCTYPEs.
* [Jason and my book][hfmw] covers some of this in chapter 3.
* Lynda.com ["History of Mobile Markup Languages" on YouTube][history-markup] is a great little summary. I think it *might* swap XHTML-MP and XHTML-Basic in the timeline, but, really, these things are pretty complex.

-------------------------------------------------------------------------------

## HTML5 is the way forward

* HTML5 by and large is tolerated by phones, even really old ones.
* No studies I know of using non-MP XHTML-variant doctypes.

#### Good enough for jazz: HTML5 is usually OK

#### Beware!: Informal HTML5 might cause choking

#### Hold that thought: Issues with HTML5 support

-------------------------------------------------------------------------------

## There's more than one way to...

* Targeting older or feature phones?
* Which is more important: bulletproof support in your market or the ability to do more powerful stuff?

#### Theme: Choice

#### Pro Tip

HTML5 is acceptable for most things, these days.

-------------------------------------------------------------------------------

## Options in markup and semantics

### Adaptive Content

* Future of content on the Web is complex
* Adaptability is key
* CMSes are the evil

#### Theme: Content


#### Handout

##### References

* [Karen McGrane][mcgrane] is a leader in adaptive content and adaptive mobile content.

-------------------------------------------------------------------------------

## One Approach

HTML as result of translation by "robots." Classes and IDs are attached to content and are auto-generated. Limited use of classes and IDs.

~~~{.html}
<section class="level2" id="we-make-the-web-mobile.">
<h2>We make the Web <em>mobile</em>.</h2>
</section>
<section class="level2" id="what-we-do">
<h2>What we do</h2>
<section class="level3" id="mobile-development">
<h3><a href="services/mobile-development.html" title="Our Mobile Development Process">Mobile Development</a></h3>
<p>Cloud Four designs and builds mobile-optimized websites and hybrid mobile applications using web technology.</p>
<p><a href="services/mobile-development.html" title="Our Mobile Development Process">Building the Mobile Web</a></p>
</section>
~~~

#### Handout

##### References

* I gave a talk about the kind of adaptive content driving this approach at [Mobilism 2012][mobilism]. See my deck [Cutting Through the Crap: The Essence of Content on the Future Web][cut-crap]
* [Cloud Four's current site](http://cloudfour.com) is built in this way.

-------------------------------------------------------------------------------

## Another Approach

~~~{.html}
<section class="scene">

  <header>
    <h4 class="stage-direction">
      Enter <strong>Caliban</strong>, <strong>Stephano</strong>, and <strong>Trinculo</strong>
    </h4>
  </header>

  <dl>
    <dt>Stephano</dt>
    <dd>
      <em class="stage-direction">(To <strong>Trinculo</strong>)</em>
      <span class="prose line">Tell not me; when the butt is out, we</span>
      <span class="prose line">will drink water; not a drop before: therefore bear up, and</span>
      <span class="prose line">board 'em. Servant-monster, drink to me.</span>
    </dd>
~~~

#### Theme: Choice

-------------------------------------------------------------------------------

## All this boils down to CONTENT

* Content-first design and process
* Stripping away crap
* This is a philosophical shift, even if it seems like "duh"
* We're going to start simple to ease into our work here

> "Simplify before you suppress." —Ethan Marcotte

#### Hold that thought: Mobile-first design

#### Theme: Content

#### Handout

##### References

* A nice post from [Jeremy Keith][adactio] from last year about [content first][adactio-content-first]
* Coverage from [Luke Wroblewski][lukew] of Jeffrey Zeldman's ["Content First"][lukew-aea-content-first] presentation at [An Event Apart October 2011][aea-oct-12].
* Stephen Hay's talk [Structured Content First][stephenhay-structured-content] is another perspective.

-------------------------------------------------------------------------------

## So what are we building today?

I was inspired by my iminent viewing of Shakespeare's *The Tempest* in Stratford-upon-Avon. I thought it might be nice to have a web-based refernce of the text of the play in a handsome, device-friendly, readable way.

Sure, there's lots of places I can find Shakespeare's content online, but none of it quite satisfies me aesthetically or on my different devices. So I thought I'd reinvent the wheel a bit.

Our little project today involves Act III, Scene 2...

## Exercise

Like I said, we're starting from scratch today. With super basic HTML5 markup. I've created a basic HTML page with the content of the 2nd scene of Act III from *The Tempest*.

There is no styling, no nothing on this page so far. And yet, if you explore it on various devices and browsers, you'll find that it starts out, even in its most basic form, feeling quite different in different places.

### [Exercise 1: Exploring the baseline](exercises/101-explore)

-------------------------------------------------------------------------------

## Workflow: getting into the browser

* Mobile web development demands the revisiting of design and development processes
* Get into the browser early and often

#### Hold that Thought: More to come on process

-------------------------------------------------------------------------------

## Basic support is good

* There is a CSS-MP to go along with XHTML-MP
* But we're going to move beyond that...

#### Good enough for jazz: Basic support is good but not infallible

#### Beware: These CSS gotchas in older devices

* Background: colors, positioning, images
* Positioning
* Selectors
* Performance!

-------------------------------------------------------------------------------

## Viewports are crazytown

### These two screenshots are from the same device, different browser

![Safari on iPhone 4](exercises/101-explore/images/iphone.png)

![Opera Mini on iPhone 4](exercises/101-explore/images/iphone-opera.png)

-------------------------------------------------------------------------------

## Viewports!

![](assets/images/viewports.png)

-------------------------------------------------------------------------------

## Or, why is the zoom all different and funny?

![](assets/images/different-viewports.png)

-------------------------------------------------------------------------------

## Layout viewport versus visible

![](assets/images/layout-visible.png)

-------------------------------------------------------------------------------

## Getting to know viewports

Before we get beyond where we are with overall layout and control, let's talk about viewports.

* Visible Viewport: The view of visible content (keyhole)
* Layout Viewport: The width of the entire layout

-------------------------------------------------------------------------------

## Anatomy of a `viewport` tag

~~~{.html}
<meta name="viewport" content="width=device-width,initial-scale=1">
~~~

* `width=device-width`: Set the viewport width to the width of the device, in CSS pixels.
* `initial-scale=1`: Set initial zoom to 1, that is, 100% or normal size.

-------------------------------------------------------------------------------

## Starting from a slightly more level playing field

* CSS Reset
* Viewport tag

-------------------------------------------------------------------------------

## Font baseline

#### Rule of thumb: font reset

![](assets/images/baseline.png)

-------------------------------------------------------------------------------

## The variations abound!

It's a bit difficult to tell from this not-so-great photo, but the background color is cream-like:

![](exercises/101-explore/images/9670.png)

-------------------------------------------------------------------------------

## Other things to consider with basic CSS

* Font differences: size, faces
* DOCTYPES

#### Exercise! Getting ur baselines going

-------------------------------------------------------------------------------

## Exercise 102

![BlackBerry 8320](exercises/102-baseline/images/8320.png)

-------------------------------------------------------------------------------

## Exercise 102

![Motorola BackFlip](exercises/102-baseline/images/backflip.png)

-------------------------------------------------------------------------------

## Exercise 102

![Kindle Fire](exercises/102-baseline/images/fire.png)

-------------------------------------------------------------------------------

## Exercise 102

![iPhone](exercises/102-baseline/images/iphone.png)

![Opera Mini on iPhone](exercises/102-baseline/images/iphone-opera.png)

-------------------------------------------------------------------------------

## Exercise 102

![Nexus S](exercises/102-baseline/images/nexus.png)

![Nexus S: FireFox](exercises/102-baseline/images/nexus-firefox.png)

-------------------------------------------------------------------------------

## Exercise 102

![Nokia N8](exercises/102-baseline/images/nokia-n8.png)

-------------------------------------------------------------------------------

## So what?

### Some things to think about

* Complexity of simplicity
* What does the word *device* mean?
* Importance of care and organization
* And the world is nowhere near this simple

-------------------------------------------------------------------------------

## Tools and Tips

* Validate, validate, validate [W3C Validator][w3c-validator]
* Start simple, when possible
* Embrace variation

TODO

## CSS Organization

* Reference to Snook, SMACSS
* Options
* Touch on pre-compilers?
* Hold that thought: precompilers

## Pro Tips

* Don't chase down every form factor
* Don't assume or assert more control than you have or is necessary
* Don't start from the top
* Don't ignore mobile issues
* Don't ignore the import of serious talent in HTML, CSS and JavaScript


--------------------------------------------------------------------------

# Part II: Towards an Adaptive Web

--------------------------------------------------------------------------

## Is this the best we can do?

![](assets/images/desktop-dull.jpg)

### Let me count the ways...

* Dull and bland
* Lines are too wide

## I want to do more

![](assets/images/desktop-enhance.jpg)

### Adding...

1. Nicer text treatment (small-caps) and bigger fonts overall (heading and body)
2. "Wrapping" the lines correctly
3. Adding an illustration

## Enhancing...

![](assets/images/desktop-enhance-2.jpg)

### Text

Emulating more forms of text layout: verse and song elements

[Let's take a look](presenter-exercises/200-strawman/tempest.html)

## What ickiness

![Nokia N8](presenter-exercises/200-strawman/images/nokia-n8.png)

![iPhone 4](presenter-exercises/200-strawman/images/iphone.png)

## Argh!

![BlackBerry 9670](presenter-exercises/200-strawman/images/9670.png)

![BlackBerry 8320](presenter-exercises/200-strawman/images/8320.png)

#### Hold that thought: Fonts on older mobile browsers


## Stop the madness!

* Situations like this emphasize the need for us to recalibrate how we think about creating for the Web
* My attempt to impose some forms of "control" over the layout and styling of the web page created havoc

## Technical causes

~~~~{.css}
body {
  width: 1060px;
}
/* ... */
h1 {
  font-size: 4em;
}
.scene {
  float: left;
}
.scene dl {
  width : 600px;
}
~~~~

### Issues

* Outsized image
* Font sizes
* Layout widths fixed, in absolute units
* [Relevant CSS](presenter-exercises/200-strawman/desktop.css)

## Let's back up

* Mobile- or content-first design thinking
* Systematized way of thinking about content and its presentation on the web
* Very relevant to the mobile evolution...and beyond

## Content-first design

* Emphasis on progressive enhancement as core tenet
* Really focusing on a *baseline experience*
* Enhancing based on browser features and/or characteristics

#### But how do we make the same HTML page look good and work well on all those different browsers and devices?

We use techniques to make our websites *adaptive*.

#### Hold that thought: Separate mobile sites/content differentiation

## Responsive Web Design (RWD)

Responsive Web Design (RWD) is a set of techniques for adapting an experience for the user's environment, instead of using a rigid, one-size-fits-all type of structure.

RWD is based upon the notion of creating a fluid, proportional layout. RWD layouts *scale, flex and adapt* to flow comfortably in the user's browser, whatever size or shape it might be at the moment.

## RWD tenets

RWD is a combination of three core tactics:

1. Fluid CSS layouts
2. Responsive Images and Objects
3. CSS3 Media Queries

## Fluidity

#### What can adaptive design via RWD do to help us get our web page in order?

Let's look again at our rather simple set of structural CSS that is getting us in trouble on some of our devices:

~~~{.css}
body {
  width: 1060px;
}
.scene {
  float: left;
}
.scene dl {
  width : 600px;
}
~~~

## Recall viewports?

![](assets/images/layout-visible.png)

* The visible viewport for our page is set to `device-width`
* The layout viewport contains the entire layout of the page, which in our case is defined by the `body` CSS rule (`1060px`).

## Fluid layouts

Fluid layouts bring visible and layout viewports into harmony, and use *proportional* layout units instead of *fixed* or *absolute* units. That way, layout can scale to different window and screen sizes.

#### Fluid CSS-based layouts are RWD tenet #1

*So how do we make layouts fluid?*

## The fluid formula

![](assets/images/fluid-formula.png)

## The fluid formula, annotated

![](assets/images/fluid-formula-explained.png)

## Applying the fluid formula

![](assets/images/fluid-example.png)

## In our case, a simple change

We can change our `body` and `.scene` rules:

* `body = 1060px / 1060px = 100%`
* `.scene = 600px / 1060px = 56.603774...%` 

### Well, one more thing

`section.illustrations` doesn't currently have a width set. Let's do this:

* `.illustrations = 30%`

#### BLEH

Ugly math:

* My fixed layout wasn't very proportional in the first place, eh?
* *To round or not to round?* I round.

## So, plug that in:

~~~{.css}
body {
  width: 100%;
}
.scene {
  float: left;
  width: 56.6%;
}
.illustrations {
  float: right;
  width: 30%;
}
~~~


## So, what did that get us?

![Sadly, not much. Much wasted space on wider windows](presenter-exercises/201-proportional/images/wide.png)

## And where'd the image go?

![The image has...disappeared](presenter-exercises/201-proportional/images/narrow.png)

## Flexible images and objects

We can solve the mystery of that missing image by using the second tenet of Responsive Web Design: **flexible images and objects**.

While the element containing the image is flexible and proportional, the image itself isn't scaling up and down to flex to its container—the container can never get narrower than the image it contains. That causes it to wrap in our layout. Uh oh.

We can add a simple rule to our CSS:

~~~{.css}
img, object {
  max-width: 100%;
}
~~~

## And...?

![](presenter-exercises/201-proportional/images/narrow2.png)

## OK, total disaster

![Nokia N8](presenter-exercises/201-proportional/images/nokia-n8.png)

![Nexus S](presenter-exercises/201-proportional/images/nexus.png)

## Yet more complications

Part of the CSS added for desktop enhancement included:

~~~{.css}
.scene dl dt, .scene dl em {
  float        : left;
  margin-right : .25em;
}

.scene dd {
  margin       : .5em 0 .5em 1.25em;
}
~~~

This affects the box model layout widths of our fluid elements and causes the wrap you see on narrow screens.

*We need to stop, catch our breath, and think about things a bit differently.*

## Letting the content dictate our flow

![](presenter-exercises/201-proportional/images/narrow2.png)

* Did you notice that even on desktop widths, the wrapping on the text of the lines of the play is wonky?
* We're coming at this backward

## What matters?

1. Making the text of this scene of the play acceptably readable on as many devices as possible
1. Presenting the text of the play in a way true to dramatic and historical form
1. Providing font and color differentiation to increase readability and contrast
1. Providing font and color differentiation to increase visual appeal
1. Showing relevant, related illustrations for this section of the play

**In that order**

We achieved much of the first goal in our first baseline layout but have since then not kept to the list of priorities...

## Let's get content-first on this thing

1. Rip out desktop-centric CSS
1. Build our baseline by enhancing our existing baseline
1. Take advantage of RWD's third tenet (Media Queries) to apply different layouts to different environments

#### Beware! Proportional layouts on their own can't get us all the way there

## We don't have to start over

Some of the CSS added to enhance the layout and appearance can stay:

* Small-caps treatment on a few selectors
* Minor styling on `figure` and `figcaption` (holds the woodcut image in our case)
* The flexible images and objects rule we added
* A few modular bits of CSS for different line types (more info coming up)

## CSS treatments for different line types

~~~{.css}
span.verse {
  clear           : both;
  display         : block;
  text-indent     : -1.5em;
  margin-left     : 1.5em;
}

span.verse-end {
  display         : block;
  float           : right;
  padding-right   : 2em;
  clear           : right;
}

span.song {
  display         : block;
  text-align      : center;
}
~~~

Explanatory notes...

## A new baseline

After ripping out desktop-specific style rules, we have a new baseline.

![Motorola Backflip](presenter-exercises/202-new-baseline/images/backflip.png)

## Looks decent...

![Nokia N8](presenter-exercises/202-new-baseline/images/nokia-n8.jpg)

![iPhone 4](presenter-exercises/202-new-baseline/images/iphone.png)

## Looks decent...

![Opera Mini on iPhone4](presenter-exercises/202-new-baseline/images/iphone-opera.png)

![Opera Mini on iPhone4](presenter-exercises/202-new-baseline/images/iphone-opera2.png)

## NOW we can enhance for wider screens

Let's use RWD's third tenet to enhance our scene page for bigger displays.

**CSS3 Media Queries** are the third leg of the RWD tripod.

Media queries allow us to apply CSS selectively depending on the current environment of the user's browser.

## Media queries explained: Media types

Media types have been around a while. It's how we make print stylesheets, e.g.

~~~{.html}

<link rel="stylesheet" media="print" href="print.css">

~~~

## Media queries explained: Media features

* Media types have media features.
* For example, `width` is a media feature of several media types. `orientation` is a media feature of various bitmap media types. `color` and `monochrome` are more examples.
* Different media types have different types of values. `color` and `monochrome` are Boolean (TRUE/FALSE) values. `width` is an integer.

The most relevant **media types** are:

* all
* screen
* print

## Logical expressions

#### CSS media queries evaluate the current value of *media features* in logical expressions to determine whether to apply the enclosed CSS.

~~~ {.css}
@media screen and (min-width: 600px) {
  // In browsers that support media queries,
  // rules in here will only be applied if the
  // query expression evaluates as true
}
~~~

### Also

~~~ {.html}
<link rel="stylesheet" media="screen and (min-width:600px)" href="thing.css">
~~~

* `@import` syntax is also supported.

## Media Queries

### Illustration: Syntax

![](assets/images/media-query-syntax.png)

## Media Queries

### Illustration: Example

![](assets/images/media-query-example.png)

But before we whip up a media query or two for the scene web page...

## Fluid isn't just for block element widths

* Fluid formula can be used to derive proportional font sizes in `em`s or percentages
* Borders, indents, padding and margin-anything dimensional

## Breakpoints and media queries

You may have heard the term **breakpoint** before.

A *breakpoint* is a window/screen width at which layout changes significantly. We can define one or more breakpoints in a layout. For example, we may want to reduce a two- or three-column layout down to a single column when the window is narrower than a certain threshold.

Generally, media queries and breakpoints have been defined in pixels in the past:

~~~ {.css}
@media screen and (min-width: 600px) {
}
~~~

* But we just talked about how things should be fluid
* ...and we're trying to design the flow of this page based on its content

Definition of `em` in notes

## Re-thinking the media query

![](assets/images/baseline.png)

* The scene lines need about `28em` to lay out correctly.
* Recall our baseline. `28em ~= 448px`. 
* That's more CSS pixels than many mobile browsers have to work with.

## That's Okay

![](presenter-exercises/202-new-baseline/images/iphone-opera2.png)

* We're allowing `span.prose` lines to wrap naturally.
* Verse lines are what matter for layout. We'd ideally like verse lines to fit on one line, but when they wrap, we want to indent them to make it clear that they are part of the previous line:

~~~{.css}
span.verse {
  clear           : both;
  display         : block;
  text-indent     : -1.5em;
  margin-left     : 1.5em;
}
~~~

## So where does that leave us?

We're pretty good on narrow screens now, but we have some enhancement to do for wider screens.

![Desktop](presenter-exercises/202-new-baseline/images/desktop.png)

## Defining a breakpoint and media query

* We know we need about `28em` or `448px` to display the text of the play
* We need a few hundred more pixels for the image to feel comfortable floating right.

~~~~
28em or 448px + 22em or 352px = 50em or 800px
~~~~

* That is, the desktop-y layout feels comfortable >= 50em or 800px

### So

**We want to wrap the CSS for enhancing for wider screens in a media query**. 

* That media query should apply for screens with widths >= 50em.
* Also, `em`s should dictate the width of our lines, not a simple percentage.


## Exercise

* Wrap CSS in a media query (I'll provide the desktop.css)
* Update the rule for .scene and .scene dl
    * For baseline rule, give `max-width: 28em`
    * Remove `width` from `.scene` (probably)
* Advanced: make image float treatment better

## Summary and pro tips

* Talk about CSS organization

-------------------------------------------------------------------------------

# Part III: Balancing a differentiated web

-------------------------------------------------------------------------------

## How are we doing?

So, we've got what seems like a solid baseline for narrow screens and a single breakpoint to adapt the layout for wider screens.

![](assets/images/desktop-rwd.png)

## Hot mess in IE

But it's a hot mess in IE8. What gives?

![](assets/images/ie8-hot-mess.png)

## Understanding media query support

### Tackling the lack of media query support

TODO: BB 8320 Screen shot

> "The absence of support for media queries is in fact the first media query."—Bryan Rieger

![](assets/images/media-query-support.png)

## Media query support options

### IE conditional tags

TODO: Steve Souders performance concern

~~~~{.css}
<link rel="stylesheet" type="text/css" href="taps.css" />
<link rel="stylesheet" type="text/css" href="layout.css" media="all and min-width: 481px)">
<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" type="text/css" href="layout.css" media="all" />
<![endif]-->
~~~~

### Polyfills

* Respond.js: <https://github.com/scottjehl/Respond>
* CSS3MediaQueries.js: <http://code.google.com/p/css3-mediaqueries-js/>

Respond is faster, but only contains a subset of CSS support. Start with it.

## Updating our web page

~~~{.html}
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="styles.css" />
  <!--[if (lt IE 9) & (!IEMobile)]>
  <link rel="stylesheet" type="text/css" href="ie.css" media="all" />
  <![endif]-->
  <title>The Tempest: Act 3, Sc. 2 | Shakespeare</title>
</head>
~~~

`ie.css` contains the same CSS as is inside the media query.

## Um.

![](assets/images/ie8-hot-mess2.png)

Turns out there's another problem here: lack of HTML5 element support.

## It's a question of features

A lot of developing for today's web is chasing down support and understanding the nitty-gritty of a lot of details.

We can help to keep some of our sanity by:

* Being good about progressive enhancement
* Thinking about things in terms of what **features** the different user agents accessing our site support
* Assessing shortcomings and fomenting a strategy about support priorities and tools to broaden support

## Some tools at our disposal

* Industry-standard techniques (e.g. IE conditional tags)
* Feature-detection code and libraries (e.g. Modernizr)
* Broadly-adopted core support tools and polyfills for broader concerns (e.g. HTML5 shim, Selectivizr)
* Libraries and polyfills for more specific concerns (e.g. video.js, placeholder.js)

## Arming ourselves

Let's try to beat IE 8 into submission, shall we?

* HTML5 Shim via Modernizr

~~~~{.html}
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="Modernizr.js"></script>
  <link rel="stylesheet" href="styles.css" />
  <!--[if (lt IE 9) & (!IEMobile)]>
  <link rel="stylesheet" type="text/css" href="ie.css" media="all" />
  <![endif]-->
  <title>The Tempest: Act 3, Sc. 2 | Shakespeare</title>
</head>
~~~~

## Better!

![](presenter-exercises/301-polyfilled/images/ie8.png)

## So, wait, tell me more about Modernizr

![](assets/images/modernizr.jpg)

* Feature detection for common HTML5 things
* Enhancing content when we have positive test results
* CSS Classes

## Font Squirrel

![](assets/images/font-squirrel.png)

## Using Modernizr and Font Squirrel to enhance

* Modernizr test for @font-face and generated content support
* Font-squirrel-generated @font-face syntax and font files

## Exercise

* Add @font-face code
* Write CSS rule for html.fontface
* Add jQuery library
* Write CSS rule for generated-content (hint: not in IE.css)

-------------------------------------------------------------------------------

# Part IV: On the frontiers of the adaptive web

-------------------------------------------------------------------------------

## Most RWD sites are not mobile First

### Reverse: Mobile RWD?

![](assets/images/mobile-rwd.png)

Jason reviewed over 100 RWD sites in 2011. Found that:

* 38% had a mobile site that was < 10% smaller than the desktop
* 4% mobile was the same size
* 25% mobile was LARGER than the desktop


## Screen size != bandwidth

Yes, this is true, but so what?

On average, mobile is still slower than desktop. We shouldn’t be delivering larger sites to mobile users.

## Why are they so big?

* Hiding a background image by using `display:none` on the element will not prevent it from downloading.
* Large desktop-size images are delivered to all devices even if they never use the image at that size.
* Media queries don’t impact JavaScript so even if you hide, for example, a Google Map, the code still downloads.

## Let's back up

Before we get specific about things, let's think about the bigger picture.

Images and other embedded things have long been a source of consternation with respect to different browsers.

### What are the high-level problems here?

* The `img` tag only provides one `src` attribute presently.
* Contrast this with `audio` and `video` HTML5 elements (so, smart folks *are* thinking about things like this)
* Some of our techniques actually cause multiple (large) images to be downloaded

These issues apply both to CSS background images and inline images. Let's take a look at some ideas for patching the problem over...

## CSS Background images

### Get your media queries in order

First thing to fix media queries is to put them in order. Small screen before large screens.

This causes means the fallback for images will be the small images, not the large ones.

### Prevent extra background image downloads

Things that work:

* Use `display:none` on the parent element
* Use media queries that don’t overlap (that is, are mutually exclusive):

~~~ {.css }
@media all and (max-width: 500px) {
    #logo {background-image:url('small.png');}
}
@media all and (min-width: 501px) {
    #logo {background-image:url('large.png');}
}
~~~

## CSS background images in different browsers

As of iOS 4.2:

* replacing a `background-image` will only result in one image being downloaded

But, `display:none` on the element itself still downloads images.

* [Tim Kadlec’s comprehensive test results for background images](http://timkadlec.com/2012/04/media-query-asset-downloading-results/)

## `image-set`

Cover this here.

## The inline HTML `img` tag conundrum

* `<img>` can only have one src attribute
* First load problem: server knows nothing about the client. How do you know what `src` to use?
* Delivering the right-sized image can mean huge savings (up to 80%) on file size.

Many people are seeking a solution for responsive images.

## Responsive images: Option 1

* JavaScript checks the width of the screen and sets a cookie.
* Image requests contain that cookie giving the server the information it needs.
* `.htaccess` file on server checks for cookie and routes requests to the correct file depending on screen size.

## Option 1 Problems

* Sometimes the browser requests images before the JavaScript executes which means the cookie isn’t set. Race condition.
* What is the fallback if cookies aren’t enabled?
* Relies on the current way browsers load content which could change. No contract between the browser and the developer.

## Responsive images: Option 2

* Put small image inside `<noscript>` tag.
* Put info for other images in `data-*` on noscript tag.
* Use javascript to build correct img tag for screen size.

~~~ {.html}
<noscript data-large="Koala.jpg" data-small="Koala-small.jpg" data-alt="Koala">
<img src="Koala.jpg" alt="Koala" />
</noscript>
~~~

## Option 2 Problems

* Markup has been changed in a way that only makes sense for this solution.
* No longer semantic.

## Responsive images: Option 3

* Use or build a service like Sencha.io SRC to deliver the correctly sized image:

~~~ {.html}
<img src="http://src.sencha.io/[ORIGINAL IMAGE URL]" />
~~~

## Option 3 Problems

* All of your images are being routed through a third-party service.
* How does Sencha know what size image to use anyways? It relies on device detection which some developers dislike.

## What we really need to solve for images

There are two separate issues when it comes to the img tag:

* Ability to authors to provide img art direction based on breakpoints
* Ensuring that the right image size is downloaded based on a combo of bandwidth, screen size, pixel density and user preference.

The picture element is focused on solving the first issue. There are a lot of different ways to address the second.


## Only real solution is new standard

~~~ {.html}
<picture alt="Giraffe">
  <source src="giraffe-sml.jpg" media="(max-width:480px)">
  <source src="giraffe-lrg.jpg" media="(min-width:481px)">
  <img src="giraffe-sml.jpg" alt="Giraffe" />
  <p>Long description</p>
</picture>
~~~

OR maybe

~~~ {.html}
<img src="face-600-200 at 1.jpeg" alt=""
     srcset="face-600-200 at 1.jpeg 600w 200h 1x,
             face-600-200 at 2.jpeg 600w 200h 2x,
             face-icon.png          200w 200h">
~~~

## The challenge is real...hard

### Some (other) things to consider

1. Canonical URL for images: multiple `src` attributes fragment a single resource into multiple URIs
2. HTTP headers: Should the future hold new HTTP headers that user agents can use to help servers serve the right things?
3. Semantics: don't box yourself in

## Lyza's crazy-ass idea of the month

I think it would be kind of neat if the CSS Media Query module spec allowed for media query references or classes.

~~~{.css}
@media narrow-all and (max-width: 30em), all and (max-width: 30em) { }
~~~

~~~~{.html}
<picture alt="My Cool Image">
  <source src="image-small.jpg" media="narrow">
  <img src="image.jpg" />
</picture>
~~~~

1. `src` in `img` tag considered canonical.
2. Named/classed media queries keep presentational media query syntax out of the markup (and have other benefits, IMHO!).

#### Beware!

This is a product of my imagination and probably represents a syntax that would conflict with older browsers, etc.


## Other RWD Challenges

* Delivering the right size video
* Breakpoint management and zoom levels
* Progressively enhancing from XHTML-MP to HTML5
* Content ordering (Flexbox can’t come soon enough*)
* Third-party widgets (particularly ad networks)
* Integrating with content management systems

* Or, at least, it can't stop *changing* soon enough

### This is all very new

No one has built a site that goes from a feature phone all the way to a television with an optimized experience for each form factor.

## Other RWD Drawbacks

## Binary fallacy

Most feature testing is thought of in a yep/nope frame of reference. But real life isn't that simple.

* Just because this older Android device supports CSS transitions...can it really handle them in a performant way?
* What does it mean if a particular feature-testing tool reports that the `canvas` tag is supported?
* And even if @fontface is supported, should we send (potentially large) font files to mobile users?

#### Beware!

Don't get lulled into a false sense of clarity or confidence about feature testing. 

## Rude awakening, BlackBerry style

![BlackBerry 9670 OS 6](presenter-exercises/302-fonts/images/9670.png)

* `small-caps` sad
* Hmmm...maybe something is odd about the combination of styles on this page...maybe something's wonky...

## It gets better

![BlackBerry 9670 OS 6](presenter-exercises/400-woes/images/9670.png)

![BlackBerry 9800 Torch OS 6](presenter-exercises/400-woes/images/9800.png)

## The coup de grace

![BlackBerry 9810](presenter-exercises/400-woes/images/9810.png)

* Used Font Squirrel to generate fonts and CSS, including the SVG font BB 6 needs
* Used Modernizr to test for @font-face support
* And this is what it looks like on a BB 9810

#### Rule of thumb: Font support on mobile is very challenging. Be wary.

## Let's back up again

This BlackBerry Torch conundrum highlights some issues:

1. Feature detection is useful but not foolproof
1. Quirks are more the rule than the exception in mobile browsers
1. We also need to look at performance and what we're trying to accomplish


## What matters?

1. Making the text of this scene of the play acceptably readable on as many devices as possible
1. Presenting the text of the play in a way true to dramatic and historical form
1. Providing font and color differentiation to increase readability and contrast
1. Providing font and color differentiation to increase visual appeal
1. Showing relevant, related illustrations for this section of the play

Objective #1 trumps objectives #2 and #3.

## But wait...

*Aren't we just flirting with the lowest common denominator again?*

### Our options

1. Leave everything as-is. Screw the buggy BlackBerry Torch.
1. Worry a lot about `@font-face` on mobile devices. Decide to put the `@font-face` rules inside of the wider-screen media query, but leave the `text-transform` and `small-caps` intact for all devices. 
1. Decide BlackBerry support is incredibly key. Move @font-face *and* other font rules (`small-caps` and `lowercase`) into the wider-screen media query.

### Things to consider

1. Whom you are supporting with your site or app.
1. Consistency.
1. Performance.

## Exercise: You are the decider

* Put @font-face rules wherever you are comfortable
* Decide on the `small-caps` and `lowercase` stuff

## A diversion about performance

## ySlow

## Progressive enhancement: electric boogaloo

* Think through what support is required for your enhancement
* Think through the dependencies
* Think through the failure states
* Consider your tools

## Line number enhancement

TODO: Screen shot of goal

On wider screens that have the real estate to do so, I'd like to display line numbers every 10 lines. That helps me keep my place when reading longer scenes.

Part of this can be done by incrementing a CSS counter on every `span.line` and using an `:after` pseudo-element to display the value of the CSS counter.

The challenge is that I'd like to do this only every 10 lines, and there isn't a viable CSS selector for that. So I need a bit of JS support here.

## Line number enhancement

All answers must be "yes":

* Can we use JavaScript to select, traverse and manipulate DOM nodes in the way we'd like in this browser?
* Does this browser support media queries?
* Is the wider-screen media query applied?
* Does this browser support generated content/:after?
* Does this browser support CSS counters?


## 2. Dependencies

* :after generated content relies on css counter support — that is, we don't want to add generated content if it is invalid
* Fortunately the set of browsers that supports :before/:after is effectively the same as those who support CSS counter

![](assets/images/generated-support.png)


## Tools

* Modernizr's integration with yepnope.js and the Modernizr.mq() test
* Conditionally load the *jQuery* library when:
    * Wider screen media query is applied
    * Modernizr.generatedcontent is true
    * Then, use jQuery selection to select and act on the DOM elements in question

## Like this

Here's the full JavaScript we'll need:

~~~{.javascript}
<script src="Modernizr.js"></script>
<script>
Modernizr.load([
  {
    test:       Modernizr.mq('only all and (min-width:50em)') && Modernizr.generatedcontent,
    yep:        '//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js',
    callback:   function(url, result, key) {
      $(document).ready(function() { 
        $('html.generatedcontent span.line').filter(function(index) {
          return (((index + 1) % 10 == 0) && index > 0);
        }).addClass('line-number');
      });
    }
  }
]);
</script>
~~~~

## Walking through the script

~~~{.html}
 <script src="Modernizr.js"></script>
~~~

This includes our custom Modernizr build with:

* `generatedcontent` testing
* `mq` (Media Query) testing
* `yepnope.js` conditional JavaScript loading
* `fontface` testing (from before!)

## Walking through more

Then: 

~~~{.javascript}
<script>
Modernizr.load([
  {
    test:       // A test or tests...truthiness is evaluated
    yep:        // If test is truthy, load this or these scripts
    callback:   // And then...
  }
]);
</script>
~~~~

## Fleshing that out...

~~~{.javascript}
Modernizr.load([
  {
    test:       Modernizr.mq('only all and (min-width:50em)') && Modernizr.generatedcontent,
    yep:        '//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js',
    callback:   // Once we're here, we know we're ready to go with our jQuery manipulation
  }
]);
</script>
~~~~

Note that we're repeating our media query verbatim. Not great, but...options are limited these days.

## And our jQuery...

~~~{.javascript}
Modernizr.load([
  {
    test:       Modernizr.mq('only all and (min-width:50em)') && Modernizr.generatedcontent,
    yep:        '//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js',
    callback:   function(url, result, key) {
      $(document).ready(function() { 
        $('html.generatedcontent span.line').filter(function(index) {
          return (((index + 1) % 10 == 0) && index > 0);
        }).addClass('line-number');
      });
    }
  }
]);
</script>
~~~~

* When document is ready, filter all `html.generatedcontent span.line` elements against the anonymous function here that returns `true` for every 10th line that isn't the first line (0). For those elements that pass this filter, add the class `line-number`.
* The non-existent CSS selector I'm emulating here is something like `html.generatedcontent span.line:nth-of-type(10n)` but doesn't reset when its parent element closes.

## The CSS

All of this within the media query for the wider screen:

~~~{.css}
/* Set up and increment the line-count counter */
.scene {
  float: left;
  counter-reset: line-count;
}
/* ... */
span.line {
  counter-increment: line-count;
}
/* ... */
/* And now the .line-number spans...show the counter value */
html.generatedcontent span.line-number:after {
  float: right;
  content: counter(line-count);
  display: inline-block;
}
~~~

## Et, voila

TODO: Screen shots

-------------------------------------------------------------------------------

# Part V: Web sites that do things, in the mobile world


## The reading web vs. the doing web

It makes a lot of us devs uncomfortable, but we can't help but notice that there is a fundamental difference between the reference-and-reading Web (Wikipedia, news sites, documentation, blogs, etc.) and the doing-stuff Web (Gmail, Flickr, etc.).

When we talk about mobile, often the glory of the app-based world makes us naturally think of the latter. Which is why I started with the former—the heart of the Web is still content.

Now it's time to talk about doing things on the mobile-device Web.

## Making Shakespeare more useful

* Adding a glossary for both unusual words, historical notes, and potentially-confusing turns of phrase
* I had a bunch of bright ideas at first

## Wouldn't it be cool if...

### An early idea

Users could touch-and-drag to highlight content in the play (a la iBooks or Kindle apps). Custom notes or simple highlights could be saved.

* On desktop it's pretty easy to access selected text using `window.getSelection()` or similar by binding to the `mouseup` and `keyup` events.
* On other devices, I can get at the selected text using the same approach, but I need to bind to different events. `touchstart` works fairly well for iOS and Androids.

## But...

Things got complicated quickly.

One idea might be to look at the results of `Modernizr.touch` (an available test in Modernizr) and change the way selected text is handled based on that.

#### Beware!

What do you think it means when `Modernizr.touch` is `true`?

## Touch events and touch models are still fractured and disparate

Not to say that touch-rich web apps cannot be successfully developed, but sorting out the nuances of each platform's touch situation was more than I wanted to dive into here. Especially as we want to support a broader set of devices than just the newest Webkit-based phones.

### I should emphasize

Such a web app is definitely possible. It's just beyond the scope of my explorations here! I wanted to demonstrate the kinds of thinking and learning that go into these sorts of exercises.

## Mobile development demands flexible, evolved thinking

Moreso in mobile than perhaps any other time in software development, BDUF (big-development-up-front), waterfalled processes tend to break down.

The unknowns are so numerous, the complications and quirks so widespread and the testing such an investment that an iterative process both in design/spec-ing and implementing sort of forces itself upon us.

Planning mobile web sites and apps seems to demand an open-ended, very flexible approach.

## A slightly more humble plan

1. Add footnotes to glossed terms and phrases and add a glossary to the end of the document.
1. For browsers and devices that support it, use JavaScript to make glossed items tappable, and pop up the definition or note in a modal dialog or lightbox.
1. Allow the user to save glossary entries. This is a bit contrived, but, hey, this is an example.

## Step 1: Glossed terms and a glossary

Step 1 is easy enough. Just need to add some HTML markup and some styles for it.

~~~{.html}
<dt>Stephano</dt>
<dd>
  <em class="stage-direction">(To <strong>Trinculo</strong>)</em>
  <span class="prose line"><span class="gloss" data-gloss="tell-not-me">Tell not me</span>; when the <span class="gloss" data-gloss="gloss-butt">butt</span> is out, we</span>
  <span class="prose line">will <span class="gloss" data-gloss="drink-water">drink water</span>; not a drop before: therefore <span class="gloss" data-gloss="bear-up">bear up, and</span></span>
  <span class="prose line"><span class="gloss" data-gloss="bear-up">board 'em</span>. Servant-monster, drink to me.</span>
</dd>
~~~

* Note the use of `data-gloss`. This will be used to match up `span.gloss` elements to the ID of their glossary counterparts.

## Step 1: A glossary section

~~~{.html}
<section class="glossary">
  <h2>Glossary</h2>
  <ol>
    <li id="tell-not-me"><em>i.e.</em> Don't tell me not to drink so much.</li>
    <li id="gloss-butt">An archaeic unit of wine, and quite a lot of it. A butt of wine around Shakespeare's time was about 126 gallons (104 imperial gallons). Compare the average US beer keg barrel size of about 15.5 gallons.</li>
~~~

etc.

TODO drawing showing mapping of gloss item to gloss content.

## Step 1: Some styles

~~~{.css}
ol {
  list-style-type: decimal;
  margin : .5em 0;
  line-height: 1.25em;
}
ol li {
  margin: .5em 2em;
}
sup {
  position : relative;
  top      : -.5em;
  font-size: .75em;
  color    : #888;
  padding  : .125em;
}
.glossary {
  float : none;
  clear : both;
}
.glossary em {
  font-style : italic;
}
~~~

## As an added bonus...

Threw in some CSS columns:

~~~{.css}
@media all and (min-width: 50em) {
  /* ... */
  .glossary ol {
    -moz-column-count   : 2;
    -moz-column-gap     : 1.5em;
    -webkit-column-count: 2;
    -webkit-column-gap  : 1.5em;
    column-count        : 2;
    column-gap          : 1.5em;
  }
}
~~~

### Why didn't I use the CSS Columns test in Modernizr before using this style?

## And now we have our baseline

At this point, we stop and test on our supported devices*.

\* I should note that, while developing the markup and styles for this example, I did find a problem in test. I had initially set a `width: 100%` on the `section.glossary` element. My `section` styles already had a padding on them, and this broke the box model and caused horizontal scrolling. C'est la vie. Easily fixed when caught at this stage. Test, iterate, test. Often.

#### Hold that thought!

We're going to have an extravaganza of testing discussion soon.

## An updated baseline

![BlackBerry 9670](presenter-exercises/500-glossed/images/9670.png)

![Nokia N8](presenter-exercises/500-glossed/images/nokia-n8.png)

![Opera Mini on iPhone](presenter-exercises/500-glossed/images/iphone-opera.png)

## Notice tablets

![iPad](presenter-exercises/500-glossed/images/ipad.png)

![iPad](presenter-exercises/500-glossed/images/ipad.png)

## Both iPad and Fire support CSS Columns

![Kindle Fire](presenter-exercises/500-glossed/images/fire.png)


## Step 2: Enhancing the glossed items

1. We'll be needing the jQuery library for everyone now, not just browsers that have the wider-screen media query applied—we need to take the conditional loading via `yepnope` away.
1. I'm somewhat randomly going to select the ["Messi"](http://marcosesperon.es/apps/messi) jQuery plugin for popups/modals. We'll need to include that JavaScript in our page and its CSS in our CSS.
1. We'll need to write a bit of jQuery JavaScript to convert our glossary entries into popup modals and make the glossed items tappable.

## Part A: Re-futzing our JavaScript

~~~
<script src="Modernizr.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="gloss.js"></script>
<script>
  $(document).ready(function() {
    if (Modernizr.generatedcontent && Modernizr.mq('only all and (min-width:50em)')) {
      $('html.generatedcontent span.line').filter(function(index) {
        return (((index + 1) % 10 == 0) && index > 0);
      }).addClass('line-number');
    }
  });
</script>
~~~

1. Including jQuery for everyone
1. Creating JavaScript for glossary items (`gloss.js`)
1. Line-number jQuery still here

## Part B and C: Messi jQuery Plugin, Glossary JavaScript

#### `gloss.js`

~~~{.javascript}
function Messi(a,b) { ... } /* Minified Messi JS */

$(document).ready(function() {
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss="' + $(this).attr('id') + '"]').click(function() {
      var $content = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary' });
    });
  });
});
~~~

Finally, added a bunch of styles to the end of `styles.css`: Messi's CSS.


## Bleh

As typical, the jQuery plugin Messi is made for desktop browsers. Its CSS is pixel-based. And there's an awful lot of it. Let's see if we can tame it.

Also, we need to add some styles of our own to indicate that the glossed items are tappable.

#### Theme: Performance optimization

The Messi CSS, lifted from Twitter Bootstrap, contains over 500 lines of CSS (more than twice the length of all of the rest of our CSS). There are many rules that aren't getting used, and a lot of pixel dimensions and gradients and animations and whatnot.

(What do you think? When should we stop using vendor prefixes and move to standard property names only?)

## Screen shots

## Refactor the CSS

* I culled the Messi CSS by about 250 lines, removing unused styles and minimizing certain CSS effects.
* I did leave in some of the button gradients and button transition effects, some opacity things and some text styling and shadows.

## Making the popups somewhat responsive

So, we need to size the popups to fit different window sizes. Messi allows you to define a width for your popups:

* Percentage widths seem appealing, but don't center in the window and look a bit ugly.
* So we need to determine what the correct width is before launching the popup: getting the width of the screen is not as straightforward as it sounds.

## Viewports again

Here's some pre-baked code to get a reasonably approximate window width:

~~~{.javascript}
function viewport() {
  return { width: window.innerWidth || 
          (document.documentElement || document.body).clientWidth, 
         height: window.innerHeight || 
          (document.documentElement || document.body).clientHeight};
}
~~~

## Updating our gloss.js

This is what we have now:

~~~~{.javascript}
$(document).ready(function() {
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss="' + $(this).attr('id') + '"]').click(function() {
      var $content = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary' });
    });
  });
});
~~~~

## Updating our gloss.js

~~~~{.javascript}
$(document).ready(function() {
  var popupWidth       = viewport().width - 30;
  popupWidth           = (popupWidth > 500) ? 500 : popupWidth;
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss ="' + $(this).attr('id') + '"]').addClass('gloss-item').click(function() {
      var $content     = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary', 
                            modal: true,
                            width: popupWidth + 'px',
                            buttons: [ { id: 'close-gloss-' + $(this).attr('data-gloss'),
                                        label: 'Close' },
                                       { id: 'save-gloss-' + $(this).attr('data-gloss'),
                                        label: 'Save',
                                        val: 'save',
                                        btnClass: 'btn-success' }]
                });
    });
  });
  function viewport() { /** ... **/  }
});
~~~~

## Nuances in a world of clicks and touches

We need to suggest, visually, that the glossed items are clickable (desktop) or tap-able (touch devices). We can start with:

~~~{.css}
span.gloss-item {
  border-bottom: 1px dashed #dcc;
}
span.gloss-item:hover,
span.gloss-item:active {
  color: #d94343;
  cursor: pointer;
}
~~~

And then update our JavaScript a teensy bit to assign the `.gloss-item` class as part of our initialization process for the glossary popups:

~~~{.javascript}
$('.glossary ol li').each(function(index) {
  $('span[data-gloss ="' + $(this).attr('id') + '"]').addClass('gloss-item').click(function() {
    /* ... */
  });
  /* ... */
});
~~~

## It's a start

* The :hover styling helps emphasize the click-ability of the spans, at least on desktop devices.
* But tapping on the spans can feel a bit cramped on touch devices. Our fingers need more room!

Let's add one more line to our JavaScript, at the end of the glossary-setup loop:

~~~{.javascript}
$('html').addClass('glossed');
~~~

Now we have `html.glossed` as a class indicating that we have a JS-driven glossary going on.

## Adjusting for touch

~~~{.css}
.glossed .scene {
  /* More line height for narrow/baseline
     when glossary items are active. */
  line-height     : 1.5em;
}
/* ... */
@media all and (min-width: 50em) {
  /* But we don't really need more room
     on wider screens, desktops */
  .scene, .glossed .scene {
    line-height: 1.3333em;
    float: left;
    counter-reset: line-count;
  }
}
~~~

## That's pretty nice


## The elephant in everyone's room: performance

* This glossary stuff works swimmingly on newer iOS devices, decent Androids, the Nokia N8, the Kindle Fire, and on the newest BlackBerrys.
* It's borderline on BlackBerry 6 devices.
* It's almost frustratingly slow on old Android (<2).

### Why?

* DOM processing
* JS inefficencies
* Complex CSS
* Slower hardware
* Less sophisticated browsers

## How could one make it better

* Rolling your own JavaScript for the popups instead of relying on a third-party, handsome, but potentially draining library
* Reducing or eliminating performance-hammering CSS (gradients, box and text shadows, transitions) altogether
* Profiling the JavaScript
* Cooking up a combination of feature- or UA-detection that indicates a "lesser" class of devices and disabling this feature on them.

#### Theme: Choice

## Client-side programming from scratch can be hard

It can get tiring if, every time you need to implement something, you have to build it from scratch. Even if you take that route, building up your own library of re-usable components and keeping them maintained as the mobile landscape sways so wildly beneath you can be challenging if not impossible.

Messi is a good example of the pros and cons of a third-party tool.

## Frameworks

## What frameworks do for us

* Often a combination of UI framework and development framework
* Solve common issues and help with cross-platform support:
    * "Mobile-like" layout vis-a-vis viewport normalization, responsive breakpoints and the like.
    * "Mobile-like" UI elements: buttons, nav bars, fixed-position toolbars, form inputs.
    * Emulation of "native-like" transitions between screens and views.
    * Navigation and AJAX loading of elements, often using the History API and pushState.
    * Abstraction layers to simplify coding against device APIs.

## Popular mobile web frameworks

* jQuery Mobile
* Sencha Touch
* [The M Project](http://the-m-project.net/)
* [DHTMLX Touch](http://www.dhtmlx.com/touch/)
* [SproutCore](http://sproutcore.com/)

## Framework and library pros and cons

### Pros

* Speeds development time, sometimes massively
* Great for prototyping
* (Greatly) eases cross-platform gotchas
* Maintained (often) by communities who are hyper-focused on specific issues (so you don't have to be)
* Provides UI elements to use as baselines

### Cons

* Often heavy, large, performance-draining
* Might not support the devices you need to
* Native UI emulation or consistent UI metaphors can encourage bland or awkward web apps
* Can be difficult to customize

## A balanced approach

Sometimes, there is a third option between framework and from-scratch. Using third-party *libraries* to solve specific issues in your development can often be a boon.

An example: AJAX-rich navigation, with dynamically-loaded content, using the History API to enable the proper usage of back buttons and refresh.

* Framework options: jQuery Mobile, Sencha Touch, etc.
* Another way: Lightweight JavaScript library like asfar.js

#### Pro Tip

Try to isolate the issue or issues you really want to solve and find a more focused library or tool to solve that problem. Try to have a good understanding of how the library or tool you end up selecting *works*.



-------------------------------------------------------------------------------

# Part VI: The State of the Web (HTML5, APIs and whatnot)

## State of the APIs

* [CanIUse.com JS APIs info](http://caniuse.com/#cats=JS_API)

## DOMStorage

> "DOM Storage is the name given to the set of storage-related features first introduced in the Web Applications 1.0 specification, and now split off into its own W3C Web Storage specification. DOM Storage is designed to provide a larger, more secure, and easier-to-use alternative to storing information in cookies. It was first introduced with Firefox 2 and Safari 4." — [Mozilla Developer Network website](https://developer.mozilla.org/en-US/docs/DOM/Storage)

* Overall situation: decent; with polyfills: quite good
* localStorage
* sessionStorage

* Cookie polyfill (https://developer.mozilla.org/en-US/docs/DOM/Storage) Caveat about maximum cookie size
* [Lawnchair](http://brian.io/lawnchair)

## File API


## mediaCapture

* Overall situation: still mostly sad
* One of the chief reasons we still reach for PhoneGap, etc.

#### Beware!

mediaCapture is really two things:
* [mediaCapture/Streams](http://www.w3.org/TR/mediacapture-streams/) aka getUserMedia aka chaos
* [HTMLInputElement](http://www.w3.org/TR/html-media-capture/)

## HTMLInputElement mediaCapture

* Implemented in Android 4 (Ice Cream Sandwich)
* Starting to show up in other mobile browsers
* `<input type="file" accept="image/*" capture="camera">`
* `capture="camcorder"` makes me giggle

## mediaCapture Streams API

* Lots of churn and change here
* No browser (mobile or otherwise) currently shipping implements this spec
* It would seem that the Tizen browser *might*

## Geolocation

* Overall status: Kinda good, actually; with polyfills: even better
* W3C GeoLocation more widely implemented than most Device APIs

## More about localStorage

* String-based key-value storage
* Strings only
* Not so much in IE

## What's the holdup?

## Things change; knowing where to look

## Using localStorage with a polyfill

* Lawnchair.js

-------------------------------------------------------------------------------

Part VI: Making sure it works

## Start broad

The majority of your testing likely will not be done on mobile devices at all.

## Hardware

## Building a device collection

* A "modern" iOS device. iPads are obviously a different form factor than iPhones, but having just one of the two covers a lot of bases.
* A "modern" Android device running Ice Cream Sandwich (OS 4) or at least Gingerbread (2.3).
* A slightly older Android running 2.0-2.2.
* A modern BlackBerry (OS 6 or newer).
* An older BlackBerry (OS 5).
* Are you in Europe? A Symbian Nokia phone.
* If your organization focuses on a demographic heavy on BlackBerrys, consider an old BlackBerry running OS 4.
* A "modern" Windows phone. The Nokia N8 and N9 are very nice devices.
* An old Android running <2.
* A device (BlackBerry has many) with an unusual aspect ratio.
* A larger-format Android device that is not a tablet, e.g. Samsung Note

## Tablets

* iPad
* Kindle Fire
* Android tablet
* BlackBerry PlayBook
* Windows 8 tablet (coming soon)

## Tactics for acquiring devices

* Add your own devices to your testing library as your replace them with newer ones. Having out-of-date devices is actually a huge boon.
* Factor in the cost of a device or two in projects focusing on those devices.
* Join developer programs at different device manufacturers. These are generally not free. BlackBerry has a well-established one. Nokia has a developer relations program as well.
* Buy devices used online (Craiglist is a great source in the U.S.; eBay is decent, too). Some can be quite cheap.
* Buying devices in the US can save money. But be very aware that the vast majority of these devices are "locked" to carrier.
* Talk to device manufacturers and mobile companies directly. It's surprising how often they're quite keen to help.
* Go to events and conferences and hope. Lots of mobile conferences give away (often many) devices as door prizes. Heck, I won a BlackBerry torch that way. If you can go to Google I/O you may well walk away with four or five devices (Cloud Four co-founder Jason did, recently).

## The biggest tip for device libraries

### TEAM UP

Connect with other developers and organizations through local user groups and the like. Chat. Swap. Trade. 

For example, the Mobile Portland group in, well, Portland, has a very active discussion list...

## Efficiencies

* Define a spot for your devices. A bookshelf, table or desk for them to live on or in.
* Keep as many devices charged as is reasonably possible.
* Group devices by charger and platform.
* Have a plan for system and software updates.
* Perform system and app updates on multiple devices at once, when possible.
* Have a work area at or near the testing library.
* Keep in mind the overhead required for device maintenance when establishing a collection.
* If you're the organized type, create a spreadsheet or somesuch for tracking the details of your devices.
* If possible, have folks borrowing your devices do their work on-site. This can be an easier sell if you have a nice work area around your devices.
* While it's good to have devices that run different versions of a given platform, you don't need to go crazy-town.


## Resources

[BagCheck Device Testing Gear](https://bagcheck.com/blog/22-mobile-device-testing-the-gear)
[BBC Devices](http://mobiletestingfordummies.tumblr.com/post/20056227958/testing)
[jQueryMobile Automated Selenium Testing](http://www.youtube.com/watch?v=51E3FWMKkig&feature=player_embedded#!)

## Testing workflows

## Remote testing and debug

* Adobe Shadow
* weinre
* shim
* Opera Dragonfly
* FireFox remote debug (NEW!)



## Emulators

* Looking for some real old stuff? http://emulator.mtld.mobi/emulator.php?emulator=nokiaN70

## Other tools

* http://responsivepx.com/

## Watch out for

* Fixed breakpoint sizes
* iOS fixation


## Some halfway techniques

Something I've done lately when doing Rails development is use the combination of:

* rSpec/Capybara
* poltergeist: Phantom.js Web driver for Capybara tests
* jasmine for JS testing

Within my test specs, I can use Phantom.js as the test driver to launch a headless instance of Webkit and run my tests within it. I can resize the (virtual) window in that Phantom.js instance to various dimensions that emulate possible mobile device widths/heights. I can test for the location and placement of elements, execute JavaScript, and take automated screen shots.

It is theoretically possible—though not on Mac right now—to run the Phantom.js as a remote to an actual device. This would be *awesome*.

This obviously only covers Webkit. Swapping over to the default Selenium web driver for Rails, I get things tested in Mozilla desktop. Though these are tests run on the desktop, they are still incredibly useful as a basis to continue testing.

## Remote testing

## What I hope is the way of the future

I would love to see the continued evolution of remote, on-hardware testing.

Some interesting stuff is happening at the confluence of Selenium and Ruby. iPhone web driver.
I hope that Shadow will evolve and allow scripting.

## Emulators


## Testing and performance tools

* jDrop
* Blaze.io

## Un-testing

The more mobile web sites you build, the more you will be able to get away with a certain amount of "un-testing." 

## Challenging Zones

* CSS positioning, box model
* CSS 3 effects, especially anything vendor-prefixed: gradients, shadows, etc.
* HTML5 elements
* DOM manipulation
* Character encoding
* Embedded media



## Ideas

* RWD
* Fluid formula
* Fluid layouts
* Flexible images/media
* Media Queries
* Media Query Management

* Performance
* `<img>` tag conundrum
* `<img>` Revisit
* Advanced CSS
* Flexbox
* The New Design Workflow

## The One Web

## Web Approach Philosophy

You're here, so you've at least partially voted for the web.



# The Differentiated Web

## Ideas

* Feature vs. device detection
* Progressive Enhancement
* Re-visit CSS; more advanced techniques
* Columns
* Animations, transitions
* Typography
* Polyfills
---
* Rolling your own
* The binary fallacy
* Behavioral vs. presentational
* Different experiences for different device classes
* UA sniffing
* DDRs

## Exercises

* Feature-testing and enhancing a layout


------------------------------------------------------
# Behaviors and APIs

## Ideas

* Geolocation
* Cross-platform consistencies
* Different types of APIs
* AppCache primer
* LocalStorage primer
* W3C
* WhatWG
* Standards in general
* Rough support charts
* JS vs. HTML APIs

## Exercises

Write geolocation script/page integration and test on device.

# Tools and Frameworks

## Ideas

* Development frameworks
* CSS frameworks
* Foundation
* Bootstrap
* beware of "responsive"
* libraries
* tools
* jQM
* Phonegap
* Modernizr redux
* Throwing libraries at the problem
* Sencha

## Exercises

Exercise idea: Style same page w/different frameworks

# Testing and Workflows

## Ideas

* Untesting
* remote debug
* Shadow
* weinre
* shim
* Dragonfly
* jDrop
* Bookmarklets
* Emulators
* Automated testing
* Devices

## Exercises

TBD

# Master Resources

[adactio]: http://adactio.com/journal
[adactio-content-first]: http://adactio.com/journal/4523/
[aea-oct-12]: http://aneventapart.com/2011/dc/
[cssweekly]: http://css-weekly.com
[cut-crap]: https://speakerdeck.com/u/lyzadanger/p/cutting-through-the-crap-the-essence-of-content-on-the-future-web
[hfmw]: http://bit.ly/hf-mw
[history-markup]: http://www.youtube.com/watch?v=egKQhGLomcQ
[lukew]: http://www.lukew.com/
[lukew-aea-content-first]: http://www.lukew.com/ff/entry.asp?1430
[mcgrane]: http://karenmcgrane.com/
[mobilism]: http://mobilism.nl
[opera-mini-simulator]: http://www.opera.com/developer/tools/mini/
[rahn-frederick]: http://www.amazon.com/Beginning-Smartphone-Web-Development-Applications/dp/143022620X
[stephenhay-structured-content]: http://www.slideshare.net/stephenhay/structured-content-first
[w3c-validator]: http://validator.w3c.org
