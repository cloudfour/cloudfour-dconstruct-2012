% dConstruct 2012: Part II
% Lyza Gardner
% September 6, 2012


# Part V: Web sites that do things, in the mobile world


## The reading web vs. the doing web

* It makes a lot of us devs uncomfortable, but we can't help but notice that there is a fundamental difference between the reference-and-reading Web (Wikipedia, news sites, documentation, blogs, etc.) and the doing-stuff Web (Gmail, Flickr, etc.).
* When we talk about mobile, often the glory of the app-based world makes us naturally think of the latter. Which is why I started with the former—the heart of the Web is still content.
* Now it's time to talk about doing things on the mobile-device Web.

## Making Shakespeare more useful

![Our Shakespeare: How to take it to the next level?](presenter-exercises/401-enhanced/images/nexus.png)

## Making Shakespeare more useful

![Our Shakespeare: How to take it to the next level?](presenter-exercises/401-enhanced/images/nexus.png)

* Adding a glossary for both unusual words, historical notes, and potentially-confusing turns of phrase
* I had a bunch of bright ideas at first

## Wouldn't it be cool if...

### An early idea

Users could touch-and-drag to highlight content in the play (a la iBooks or Kindle apps). Custom notes or simple highlights could be saved.

* On desktop it's pretty easy to access selected text using `window.getSelection()` or similar by binding to the `mouseup` and `keyup` events.
* On other devices, I can get at the selected text using the same approach, but I need to bind to different events. `touchstart` works fairly well for iOS and Androids.

## But...

Things got complicated quickly.

One idea might be to look at the results of `Modernizr.touch` (an available test in Modernizr) and change the way selected text is handled based on that.

### For your consideration

What do you think it means when `Modernizr.touch` is `true`?

## Touch events and touch models are still fractured and disparate

Not to say that touch-rich web apps cannot be successfully developed, but sorting out the nuances of each platform's touch situation was more than I wanted to dive into here. Especially as we want to support a broader set of devices than just the newest Webkit-based phones.

### I should emphasize

Such a web app is definitely possible. It's just beyond the scope of my explorations here! I wanted to demonstrate the kinds of thinking and learning that go into these sorts of exercises.

### Real world moment

Feasibility is a function of many things. In my case, I decided to do something simpler.

## Mobile development demands flexible, evolved thinking

* Moreso in mobile than perhaps any other time in software development, BDUF (big-development-up-front), waterfalled processes tend to break down.
* The unknowns are so numerous, the complications and quirks so widespread and the testing such an investment that an iterative process both in design/spec-ing and implementing sort of forces itself upon us.
* Planning mobile web sites and apps seems to demand an open-ended, very flexible approach.

## A slightly more humble plan

![Add footnotes to glossed terms and phrases](assets/images/footnotes.png)

![...and add a glossary to the end of the document](assets/images/glossary.png)

## A slightly more humble plan

![For browsers that support it, use JavaScript to make glossed items tappable](assets/images/tappable.png)

![...and pop up definitions in a modal or lightbox-y thing](assets/images/popup.png)

## A slightly more humble plan

![Allow the user to save glossary entries. This is a bit contrived, but, hey, this is an example](assets/images/saved-items.png)

### Hold that thought!

We'll implement saved items in a little bit. First, to gloss!

## Building our do-something web thing

There are three steps to making our enhanced Shakespeare:

1. Add HTML markup and basic styling (this section)
2. Enhance with pop-up definitions and a prototype of the save-glosses process (this section)
3. Implement the saving of glossary items (next section)

## Step 1: Glossed terms and a glossary

Step 1 is easy enough. Just need to add some HTML markup and some styles for it.

~~~{.html}
<dt>Stephano</dt>
<dd>
  <em class="stage-direction">(To <strong>Trinculo</strong>)</em>
  <span class="prose line"><span class="gloss" data-gloss="tell-not-me">Tell not me</span>; when the <span class="gloss" data-gloss="gloss-butt">butt</span> is out, we</span>
  <span class="prose line">will <span class="gloss" data-gloss="drink-water">drink water</span>; not a drop before: therefore <span class="gloss" data-gloss="bear-up">bear up, and</span></span>
  <span class="prose line"><span class="gloss" data-gloss="bear-up">board 'em</span>. Servant-monster, drink to me.</span>
</dd>
~~~

* Note the use of `data-gloss`. This will be used to match up `span.gloss` elements to the ID of their glossary counterparts.
* You can see the end result in the `index.html` file in [presenter-exercises/500-glossed/index.html](presenter-exercises/500-glossed/index.html)

## Step 1: A glossary section

~~~{.html}
<section class="glossary">
  <h2>Glossary</h2>
  <ol>
    <li id="tell-not-me"><em>i.e.</em> Don't tell me not to drink so much.</li>
    <li id="gloss-butt">An archaeic unit of wine, and quite a lot of it. A butt of wine around Shakespeare's time was about 126 gallons (104 imperial gallons). Compare the average US beer keg barrel size of about 15.5 gallons.</li>
~~~

etc.

## Glossary markup

![](assets/images/glossary-structure.jpg)

## Step 1: Some styles

* Our CSS reset wiped out any margins, etc. for `<ol>`, `<sup>` and `<li>` elements
* Positioning on `sup` rule is to avoid `sup` text making line-spacing weird

~~~{.css}
ol {
  list-style-type: decimal;
  margin : .5em 0;
  line-height: 1.25em;
}
ol li {
  margin: .5em 2em;
}
sup {
  position : relative;
  top      : -.5em;
  font-size: .75em;
  color    : #888;
  padding  : .125em;
}
.glossary {
  float : none;
  clear : both;
}
.glossary em {
  font-style : italic;
}
~~~

## As an added bonus...

Threw in some CSS columns:

~~~{.css}
@media all and (min-width: 50em) {
  /* ... */
  .glossary ol {
    -moz-column-count   : 2;
    -moz-column-gap     : 1.5em;
    -webkit-column-count: 2;
    -webkit-column-gap  : 1.5em;
    column-count        : 2;
    column-gap          : 1.5em;
  }
}
~~~

## CSS-Columns

### For your consideration

* Why didn't I use the CSS Columns test in Modernizr before using this style?
* Do you know of any other CSS modules or new features I could have used to do the layout for this section?

### Further reading

* [CSS3-Columns post on quirksmode](http://www.quirksmode.org/css/multicolumn.html)
* [Columns page on Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/CSS/columns)

## And now we have our baseline (Step 1 is complete!)

At this point, we stop and test on our supported devices*.

\* I should note that, while developing the markup and styles for this example, I did find a problem in test. I had initially set a `width: 100%` on the `section.glossary` element. My `section` styles already had a padding on them, and this broke the box model and caused horizontal scrolling. C'est la vie. Easily fixed when caught at this stage. Test, iterate, test. Often.

[Our glossed items, baseline markup](presenter-exercises/500-glossed/tempest.html)

#### Hold that thought!

We're going to have an extravaganza of testing discussion soon.

## An updated baseline

![BlackBerry 9670](presenter-exercises/500-glossed/images/9670.png)

![Nokia N8](presenter-exercises/500-glossed/images/nokia-n8.png)

![Opera Mini on iPhone](presenter-exercises/500-glossed/images/iphone-opera.png)

## Notice tablets

![iPad](presenter-exercises/500-glossed/images/ipad.png)

### Pro tip

I did some testing on tablets here because of the CSS columns change. More on testing later!

## Both iPad and Fire support CSS Columns

![Kindle Fire](presenter-exercises/500-glossed/images/fire.png)

* It is likely your [desktop browser might, too](presenter-exercises/500-glossed/tempest.html)
* Step 1 complete!

## Step 2: Enhancing the glossed items

1. We'll be needing the jQuery library for everyone now, not just browsers that have the wider-screen media query applied—we need to take the conditional loading via `yepnope` away.
1. I'm somewhat randomly going to select the ["Messi"](http://marcosesperon.es/apps/messi) jQuery plugin for popups/modals. We'll need to include that JavaScript in our page and its CSS in our CSS.
1. We'll need to write a bit of jQuery JavaScript to convert our glossary entries into popup modals and make the glossed items tappable.

### Real world moment

The many iterations in developing and enhancing for the mobile web often means refactoring what you already have.

### [Exercise: Getting to know our jQuery plugin, Messi](exercises/501-messi)

## Part A: Re-futzing our JavaScript

~~~{.html}
<script src="Modernizr.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="gloss.js"></script>
<script>
  $(document).ready(function() {
    if (Modernizr.generatedcontent && Modernizr.mq('only all and (min-width:50em)')) {
      $('html.generatedcontent span.line').filter(function(index) {
        return (((index + 1) % 10 == 0) && index > 0);
      }).addClass('line-number');
    }
  });
</script>
~~~

`tempest.html`

*. Including jQuery for everyone
*. Creating JavaScript for glossary items (`gloss.js`)
*. Line-number jQuery still here

## Part B and C: Messi jQuery Plugin, Glossary JavaScript

~~~{.javascript}
function Messi(a,b) { ... } /* Minified Messi JS */

$(document).ready(function() {
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss="' + $(this).attr('id') + '"]').click(function() {
      var $content = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary' });
    });
  });
});
~~~

`gloss.js`

Finally, added a bunch of styles to the end of `styles.css`: Messi's CSS.

## Putting this stuff together

![](assets/images/messi-structure.jpg)

## Looks OK on my desktop...

![](presenter-exercises/501-popups/images/chrome.png)

* We can [try it out](presenter-exercises/501-popups/tempest.html)

## But...

![Oh, boy](presenter-exercises/501-popups/images/iphone.png)

## Bleh

* As typical, the jQuery plugin Messi is made for desktop browsers. Its CSS is pixel-based. And there's an awful lot of it. Let's see if we can tame it.
* Also, we need to add some styles of our own to indicate that the glossed items are tappable.

The Messi CSS, lifted from Twitter Bootstrap, contains over 500 lines of CSS (more than twice the length of all of the rest of our CSS). There are many rules that aren't getting used, and a lot of pixel dimensions and gradients and animations and whatnot.

### Beware!

Most things in the web world still aren't ready to be dropped, wholesale, into a mobile-friendly context. We have to pay strict attention!

## Refactoring the CSS

* I culled the Messi CSS by about 250 lines, removing unused styles and minimizing certain CSS effects.
* I did leave in some of the button gradients and button transition effects, some opacity things and some text styling and shadows.

### Hold that thought!

This could still be better-optimized

## Making the popups somewhat responsive

![Popup windows need to be flexible in size](presenter-exercises/501-popups/images/iphone.png)

So, we need to size the popups to fit different window sizes. Messi allows you to define a width for your popups:

* Percentage widths seem appealing, but don't center in the window and look a bit ugly.
* So we need to determine what the correct width is before launching the popup: getting the width of the screen is not as straightforward as it sounds.

### For your consideration

How do we figure out how wide the popup should be?

## Viewports again

Here's some pre-baked code to get a reasonably approximate window width:

~~~{.javascript}
function viewport() {
  return { width: window.innerWidth || 
          (document.documentElement || document.body).clientWidth, 
         height: window.innerHeight || 
          (document.documentElement || document.body).clientHeight};
}
~~~

### Further reading

* [Relevant post on Quirskmode](http://www.quirksmode.org/blog/archives/2010/08/combining_media.html)

## Still more CSS brutalization

![](presenter-exercises/501-popups/images/nokia-n8.jpg)

* The Messi CSS, even shortened, is making some assumptions about CSS layout. It uses `flexbox` or `box` layouts, which this Windows Phone browser doesn't grok.
* I tend to find it ironic that Twitter Bootstrap gets touted as a "mobile-friendly" and "responsive" CSS framework.

### Beware!

* There is no international committee monitoring the fair usage of "responsive." It means...different things to different people.

## Updating our gloss.js

This is what we have now:

~~~~{.javascript}
$(document).ready(function() {
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss="' + $(this).attr('id') + '"]').click(function() {
      var $content = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary' });
    });
  });
});
~~~~

`gloss.js`

## Updating our gloss.js

~~~~{.javascript}
$(document).ready(function() {
  var popupWidth       = viewport().width - 30;
  popupWidth           = (popupWidth > 500) ? 500 : popupWidth;
  $('.glossary ol li').each(function(index) {
    $('span[data-gloss ="' + $(this).attr('id') + '"]').addClass('gloss-item').click(function() {
      var $content     = $('li#' + $(this).attr('data-gloss')).html();
      new Messi($content, { title: 'Glossary', 
                            modal: true,
                            width: popupWidth + 'px',
                            buttons: [ { id: 'close-gloss-' + $(this).attr('data-gloss'),
                                        label: 'Close' },
                                       { id: 'save-gloss-' + $(this).attr('data-gloss'),
                                        label: 'Save',
                                        val: 'save',
                                        btnClass: 'btn-success' }]
                });
    });
  });
  function viewport() { /** ... **/  }
});
~~~~

### Hold that thought!

* This is prototyped jQuery code. It gets cleaned up and organized later...

## Nuances in a world of clicks and touches

We need to suggest, visually, that the glossed items are clickable (desktop) or tap-able (touch devices). We can start with:

~~~{.css}
span.gloss-item {
  border-bottom: 1px dashed #dcc;
}
span.gloss-item:hover,
span.gloss-item:active {
  color: #d94343;
  cursor: pointer;
}
~~~

`styles.css`

And then update our JavaScript a teensy bit to assign the `.gloss-item` class as part of our initialization process for the glossary popups:

~~~{.javascript}
$('.glossary ol li').each(function(index) {
  $('span[data-gloss ="' + $(this).attr('id') + '"]').addClass('gloss-item').click(function() { /* ... */ });
  /* ... */
});
~~~

`gloss.js`

## It's a start

* The `:hover` styling helps emphasize the click-ability of the spans, at least on desktop devices.
* But tapping on the spans can feel a bit cramped on touch devices. Our fingers need more room!

Let's add one more line to our JavaScript, at the end of the glossary-setup loop:

~~~{.javascript}
$('html').addClass('glossed');
~~~

Now we have `html.glossed` as a class indicating that we have a JS-driven glossary going on.

## Adjusting for touch

~~~{.css}
.glossed .scene {
  /* More line height for narrow/baseline
     when glossary items are active. */
  line-height     : 1.5em;
}
/* ... */
@media all and (min-width: 50em) {
  /* But we don't really need more room
     on wider screens, desktops */
  .scene, .glossed .scene {
    line-height: 1.3333em;
    float: left;
    counter-reset: line-count;
  }
}
~~~

### Good enough for jazz

* Technically, this is not adjusting for touch. It's adjusting for screen size. But there is a lot of correlation between narrow screen sizes and touch screens.

## Recap

A lot of stuff just happened. In a nutshell:

1. Messi CSS was culled, twice, to get rid of unused styles and make remaining one works OK on mobile devices
1. We added some styles to our own CSS to make tap-able, glossed items indicated as such. We then added these styles as needed via JS
1. We used a small JS function to determine viewport width to help us decide how wide to make the Messi popup modal
1. We adjusted styling for wider screens

### Good enough for jazz

Sure, at the end of step 2 here, we're not done implementing the saved-gloss feature, and some of our edges are rough. But prototype steps like this are important in the process of developing for the mobile—or any—web.

## That's pretty nice

![BlackBerry 9670](presenter-exercises/502-responsive-popups/images/9670.png)

![Kindle Fire](presenter-exercises/502-responsive-popups/images/fire.png)

## More better for touch

![Behaves nicely on the iPhone](presenter-exercises/502-responsive-popups/images/iphone.png)

![Increased line-height and visual cues for tappable items](presenter-exercises/502-responsive-popups/images/iphone2.png)

## It works on Opera Mini...but

![Opera Mini is a proxy browser](presenter-exercises/502-responsive-popups/images/opera-iphone2.png)

![Why is the line-height so scrunched?](presenter-exercises/502-responsive-popups/images/opera-iphone.png)

## Surprise.

![Turns out Opera Mini doesn't support line-height](presenter-exercises/502-responsive-popups/images/opera-line-height.png)

![Same document rendered on an iPhone](presenter-exercises/502-responsive-popups/images/iphone-line-height.png)

## The elephant in everyone's room: performance

* This glossary stuff works swimmingly on newer iOS devices, decent Androids, the Nokia N8, the Kindle Fire, and on the newest BlackBerrys.
* It's borderline on BlackBerry 6 devices.
* It's almost frustratingly slow on old Android (<2).

### Why?

* DOM processing
* JS inefficencies
* Complex CSS
* Slower hardware
* Less sophisticated browsers

### Real world moment

## How could one make it better

* Rolling your own JavaScript for the popups instead of relying on a third-party, handsome, but potentially draining library
* Reducing or eliminating performance-hammering CSS (gradients, box and text shadows, transitions) altogether
* Profiling the JavaScript
* Cooking up a combination of feature- or UA-detection that indicates a "lesser" class of devices and disabling this feature on them.

### Hold that thought!

We'll come back to optimization and performance

## Client-side programming from scratch can be hard

It can get tiring if, every time you need to implement something, you have to build it from scratch. Even if you take that route, building up your own library of re-usable components and keeping them maintained as the mobile landscape sways so wildly beneath you can be challenging if not impossible.

Messi is a good example of the pros and cons of a third-party tool.

### Pro Tip

You can find all of the code for the examples in this section in the `presenter-exercises` directory inside of `500-glossed` (markup/baseline CSS only), `501-popups` (popups that work on desktop only) and `502-reponsive-popups` (popups sized appropriately for mobile) subdirectories.

# Interlude: Frameworks

## What frameworks do for us

* Often a combination of UI framework and development framework
* Solve common issues and help with cross-platform support:
    * "Mobile-like" layout vis-a-vis viewport normalization, responsive breakpoints and the like.
    * "Mobile-like" UI elements: buttons, nav bars, fixed-position toolbars, form inputs.
    * Emulation of "native-like" transitions between screens and views.
    * Navigation and AJAX loading of elements, often using the History API and pushState.
    * Abstraction layers to simplify coding against device APIs.

## Popular mobile web frameworks

* [jQuery Mobile](http://jquerymobile.com)
* [Sencha Touch](http://www.sencha.com/products/touch)
* [The M Project](http://the-m-project.net/)
* [DHTMLX Touch](http://www.dhtmlx.com/touch/)
* [SproutCore](http://sproutcore.com/)

## Framework and library pros and cons

### Pros

* Speeds development time, sometimes massively
* Great for prototyping
* (Greatly) eases cross-platform gotchas
* Maintained (often) by communities who are hyper-focused on specific issues (so you don't have to be)
* Provides UI elements to use as baselines

### Cons

* Often heavy, large, performance-draining
* Might not support the devices you need to
* Native UI emulation or consistent UI metaphors can encourage bland or awkward web apps
* Can be difficult to customize

## A balanced approach

Sometimes, there is a third option between framework and from-scratch. Using third-party *libraries* to solve specific issues in your development can often be a boon.

An example: AJAX-rich navigation, with dynamically-loaded content, using the History API, pushstate/popstate to enable the proper usage of back buttons and refresh.

* Framework options: jQuery Mobile, Sencha Touch, etc.
* Another way: Lightweight JavaScript library like asfar.js

#### Pro Tip

Try to isolate the issue or issues you really want to solve and find a more focused library or tool to solve that problem. Try to have a good understanding of how the library or tool you end up selecting *works*.


# Part VI: The web as a platform: HTML5, APIs, oh, my!

-------------------------------------------------------------------------------

## HTML5 is complicated and confusing

* What is HTML5?
* What is a device API?
* Is there a difference between an HTML API and a JavaScript API?
* Who manages all this stuff?
* What's the difference between the W3C and the WHATWG?
* What works where?

## What is the web?

* A bunch of HTML stuff
* A bunch of CSS stuff
* A bunch of media stuff
* JavaScript stuff
* Stuff that interacts with the hardware
* Sorta random stuff
* Server and programming stuff
* Seriously low-level stuff (HTTP, TCP/IP)

## WHATWG? W3C? What *is* HTML5?

* Jeremy Keith's [*HTML for Web Designers*](http://www.abookapart.com/products/html5-for-web-designers) discusses the origins, evolution and relationship between the W3C, the WHATWG and other parties.
* ["Is this HTML5?" section on WHATWG HTML spec](http://www.whatwg.org/specs/web-apps/current-work/multipage/introduction.html#is-this-html5?) helps to iron out a few things.


And all of this is whirling and changing so fast. And *what about mobile?*

## Mobile browser support of HTML5 things actually quite good, But not everywhere

### Proxy browsers

* When proxy browsers are involved, we lose the "device" in the equation.
* Device and platform interaction is by nature very restricted.

### Older devices

* Older browsers are obviously fairly limited.
* The older the device is, the less likely it is to have a browser that can or is updated frequently or ever (unscientific).

## What is a device API?

#### [According to the W3C](http://www.w3.org/2009/dap/)

* Battery Status
* Media Capture (HTML and JS)
* Network Information
* Ambient Light, Humidity and Temperature Events
* Proximity Events
* Vibration
* Web, Pick Media, and Pick Contacts Intents
* Calendar
* Menu

## Brian LeRoux defines device APIs:

> "Typically headless/chrome[le]ss/without a visual manifestation, truly crossplatform." —[Brian LeRoux](http://brian.io/slides/beyond-html5/#/23), PhoneGap (Adobe)

He goes on to expand that these APIs usually involve:

* sensors
* data
* outputs

## Back to that W3C list...

* Battery Status
* Media Capture (HTML and JS)
* Network Information
* Ambient Light, Humidity and Temperature Events
* Proximity Events
* Vibration
* Web, Pick Media, and Pick Contacts Intents
* Calendar
* Menu

## For your consideration

* What's missing here?
* Anything else seem odd to you?

## Device APIs...yeah, it's cloudy

* **[Geolocation](http://www.w3.org/TR/geolocation-API/)**: Its own thing in the W3C
* **Accelerometer, Device Orientation**: Under the auspices of geolocation
* **[File API](http://www.w3.org/TR/FileAPI/) and related**: [Web Applications Working Group](http://www.w3.org/2008/webapps/)
* Everyone's list of device APIs is different
* Device APIs are one piece of the puzzle of HTML5 and the web

## The web as platform

![Platform.html5.org](assets/images/html5-platform.jpg)

## What we've seen already

![What we've seen today](assets/images/what-weve-seen.png)

## Mobile-relevant device APIs

![These APIs are hot in mobile](assets/images/mobile_relevant_apis.jpg)

* Pink: Device APIs (roughly)
* Blue: Other APIs and features relevant to mobile (roughly)
* As more of these APIs get implemented in real-life mobile browsers, the need to go native for certain platform-level things diminishes
* Until then: Hybrid development

## Geolocation

* Leaps to mind when we think about mobile
* Find out where the device (on which the browser is running) is
* One of the more widely-implemented device APIs in-browser
* W3C specification is pretty easy to get your head around
* Is a good example of typical device API progression:
    1. Proprietary, native-only availability
    2. Proprietary in-browser availability
    3. Scattered standards-based support in browser
    4. Broader standards-based support in browsers, with polyfill fallbacks
    5. (Not yet/the ideal state) Pervasive standards-based support in (nearly) all browsers

## Geolocation

* Modern browsers have near-universal implementation of geolocation of some kind
* Notable exceptions are no surprise:
    * IE < 9
    * Opera Mini (remember what we said about proxy browsers)
* Blackberry < 7 and some other legacy mobile browsers use different implementations

## The W3C Geolocation spec

* The [W3C's geolocation spec](http://www.w3.org/TR/geolocation-API/) is widely implemented and pretty straightforward.
* Browsers that implement the API expose the `navigator.geolocation` object.
* The key method on that object is `getCurrentPosition(successCallback, failCallback)`.

## An example

~~~{.javascript}
<script>
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(onGeoSuccess, onGeoError);
}
function onGeoSuccess(position) {
  var coordinates = position.coords;
  alert(coordinates.latitude + ", " + coordinates.longitude);
}
function onGeoError(error) { alert(error.message); }
</script>
~~~

* Here's [an example in an HTML page you can try](presenter-exercises/600-geolocation).

## With polyfill

* It's common to use a polyfill with device APIs to reach more browsers that may have disparate implementations.
* A commonly-used polyfill for geolocation is [geo-location-javascript](http://code.google.com/p/geo-location-javascript/), though it is less useful now that Google Gears has been discontinued.
* geo-location-javascript, like many/most polyfills, emulates the existing or proposed standard. Thus, though there is a one-line initiation snippet, geo-location-javascript lets you use the same syntax as the W3C standard geolocation API.


## I can't really teach you about device APIs

* I can give you a high-level overview
* Things are changing so fast that it's more of a game of knowing where to look for information

## And where would that be?

* [The Web platform: Browser technologies](http://platform.html5.org/)
* [HTML5Please](http://html5please.com/)
* [CanIUse JS APIs](http://caniuse.com/#cats=JS_API)
* [Device APIS WG at W3C](http://www.w3.org/2009/dap/)
* [Mozilla Developer Network HTML5 Section](https://developer.mozilla.org/en-US/docs/HTML/HTML5)
* [HTML5 Polyfills from Modernizr](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills) A list of tons of polyfills

### Further reading

* [.net Magazine Article](http://www.netmagazine.com/features/developer-s-guide-html5-apis)
* [Slide deck from Brian LeRoux on Device APIs](http://brian.io/slides/beyond-html5/)

## MediaCapture API

#### Beware!

* Actually two things
    * [HTMLInputElement](http://www.w3.org/TR/html-media-capture/): New form `<input>` type
    * [mediaCapture/Streams](http://www.w3.org/TR/mediacapture-streams/): Somewhat confusing (mostly in that it is ever-changing/hard to pin down) JavaScript/Programmatic API

### MediaCapture

* Lets you get at the device's camera and audio recording for capturing media streams and (slightly confusing) still images
* Media Capture non-support is one of the chief reasons we still need to go native for a lot of things. That's when we reach for [PhoneGap](http://phonegap.com/).

## HTMLInputElement mediaCapture

* Implemented in Android 4 (Ice Cream Sandwich)
* Starting to show up in other mobile browsers
* `<input type="file" accept="image/*" capture="camera">`
* `capture="camcorder"` makes me giggle
* Remember, this is the HTML API piece of this, not the programmatic "control the user's camera" piece

## mediaCapture Streams API

* Lots of churn and change here
* No browser (mobile or otherwise) currently shipping implements this spec
* It would seem that the Tizen browser *might*

## Yet MOAR Device/Mobile-relevant APIs

* Network Information API
* Battery Status API
* Vibration
* Device Orientation
* File, Filesystem stuff
* Offline Applications
    * My personal nightmare
    * ApplicationCache (AppCache) sounds straightforward, but it is really terrifying; have lost many days of my life to this beast
    * I punt you to [Jake Archibald's fantastic AppCache: DoucheBag presentation](http://vimeo.com/43336762) (amusing, informative and thorough—I can't possibly compete)

## DOMStorage/Web Storage

> "DOM Storage is the name given to the set of storage-related features first introduced in the Web Applications 1.0 specification, and now split off into its own W3C Web Storage specification. DOM Storage is designed to provide a larger, more secure, and easier-to-use alternative to storing information in cookies. It was first introduced with Firefox 2 and Safari 4." — [Mozilla Developer Network website](https://developer.mozilla.org/en-US/docs/DOM/Storage)

### [Exercise: Research Web Storage](exercises/601-dom-storage)

## `localStorage` in a nutshell

### What is `localStorage` and how does it relate to `Web Storage` a.k.a. `DOM Storage`?

* `localStorage` is part of the DOM Storage/Web Storage API oeuvre along with `sessionStorage`.
* Allows for straightforward storage and retrievel of string key-value pairs.
* Both the key and the value must be strings.
* Different platforms allot different amounts of space for `localStorage`. Behaviors can differ when `localStorage` gets full.

## Which browsers support it?

![Information from caniuse.com](assets/images/local-storage-support.png)

* Broadly supported
* No real surprises that the outliers would be IE and Opera Mini. IE 8 even supports it

## Polyfills for `localStorage`

* [Cookie polyfill](https://developer.mozilla.org/en-US/docs/DOM/Storage)
* [Remy Sharp's polyfill for Web Storage](https://gist.github.com/350433)
* Several more polyfills are [listed on Modernizr](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)
* You can also use [Lawnchair's DOM adapter](http://brian.io/lawnchair/)

#### Beware!

Many `localStorage` polyfills use cookies. The cookie polyfill is limited by one of the very things that `localStorage` was intended to relieve: maximum cookie size. 4kb is the max size for any cookie. The lowest common denominator is IE6, which may allow as few as 20 cookies per domain. Also, cookies are sent with every request—expensive overhead on high-latency connections.

## Other client and device persistence/data/file options

### Further reading

* [IndexedDB](http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html)
* [File API](http://dev.w3.org/2006/webapi/FileAPI/)
* [Application Cache/Offline](http://dev.w3.org/html5/spec/offline.html#offline)
* Blob URLs, [Data URLs](http://tools.ietf.org/html/rfc2397)

## HTML5Please has a bit of a different perspective than CanIUse...

![](assets/images/html5please-localstorage.png)

## In which I prototype a save-gloss feature

* Recall that so far, steps 1 and 2 of the save-gloss feature are done:
    1. HTML and CSS baseline markup
    2. JS and CSS enhancement; prototype of definition pop-ups and interface
* Now it's time for step 3

### Beware!

Here comes some JavaScript!

1. I'm going to gloss over some of the finer details of the implementation here
1. I don't want you to gloss over too hard
1. I'll provide links to more details for the curious

## Step 3: make it so

![When a user taps on the Save Button](presenter-exercises/502-responsive-popups/images/iphone.png)

![The glossed item should be saved](presenter-exercises/601-prototype/images/nokia-n8.png)


## Structure

* Re-factoring the prototyped JavaScript
    * `GlossStorage` class to handle interacting with `localStorage`
    * jQuery extension that relies on Messi
* Adding some CSS to display saved glossary items in a list
* Unobtrusive JS: No changes to HTML markup

## JavaScript (well, jQuery) Structure

~~~{.javascript}
(function($) {
  function GlossStorage() {
    /* An object to handle interactions with localStorage */
  };

  $.fn.gloss = function() {
    /* My own jQuery plugin/extension */
  }

})( jQuery ); // Both within a closure

$(document).ready(function() {
  $('.scene').gloss(); // Invoking the jQuery plugin
});
~~~~

## GlossStorage

~~~{.javascript}
(function($) {
  function GlossStorage() {
    var savedGlosses  = [],
        glossKey      = 'glosses';

    this.supported = function() {
      return (typeof JSON != 'undefined'
                && typeof JSON.stringify      != 'undefined' 
                && typeof window.localStorage != 'undefined');
    };
    this.save   = function(gloss) { };
    this.has    = function(gloss)  { };
    this.all    = function() {  };
    this.clear  = function() {  }; 
    if (this.supported()) {
      savedGlosses = [];
      if (localStorage.getItem(glossKey)) {
        savedGlosses = JSON.parse(localStorage.getItem(glossKey));
      }
    }
  };

  /** jQuery plugin after this ...*/
})( jQuery );
~~~

`gloss.js`

## Test for `localStorage`

* I decided to roll my own and not use a polyfill

~~~{.javascript}
this.supported = function() {
  return (typeof JSON != 'undefined'
            && typeof JSON.stringify      != 'undefined' 
            && typeof window.localStorage != 'undefined');
};
~~~

* The rest of the `GlossStorage` class interacts with `localStorage` using its API:
    * `getItem`
    * `setItem`
    * `removeItem`

## jQuery Plugin

~~~{.javascript}
$.fn.gloss = function() {
    var showGloss        = function($glossItem, glossId) { }; // Pop up definition
    var saveGloss        = function(val) {    }; // Save gloss in GlossStorage and update display
    var showSavedGlosses = function() {    }; // Add some elements to hold and display saved glosses
    var buildSavedList   = function(glosses) {  }; // Generate/update a <dl> with all saved glosses
    var clearGlosses     = function() {   }; // Clear glosses out of GlossStorage and update display
    var viewportSize     = function() {   }; // From our previous Messi implementation
    var init             = function() {
      var glosses;
      storage           = new GlossStorage();
      showSavedGlosses();
      // Slightly more formalized way of finding all the glossary definitions
      // And making references to them clickable and styled and ready to
      // pop up definitions
      $(glossarySelector).find(glossDefinitionSelector).each(function() {
        var glossId     = $(this).attr('id'),
            $glossItems = $('[data-gloss ="' + glossId + '"]');
        $glossItems.addClass(glossClass).toggleClass(savedGlossClass, storage.has(glossId));
        $glossItems.click(function(event) { showGloss($(this), glossId); });
      });
    }();
  }
~~~

`gloss.js` detail

## CSS

~~~{.css}
div.saved-glosses {
  background-color       : #e8e9de;
}
div.saved-glosses h3 {
  padding                : .5em;
  cursor                 : pointer;
}
.remove-glosses {
  cursor                 : pointer;
  font-size              : 1.25em;
  padding                : .25em 0;
}
.remove-glosses:before {
  content                : 'x';
  font-size              : .75em;
  margin-right           : .5em;
  color                  : #d94343;
}
div.saved-glosses h3:before {
  display                : inline-block;
  width                  : 1.5em;
  margin-right           : .5em;
  content                : "\25B6";
  font-size              : .5em;
}
div.saved-glosses.open h3:before {
  content: "\25BC";
}
~~~

## MOAR CSS

~~~{.css}

div.saved-glosses dl {
  display                : none;
}
div.saved-glosses dt {
  text-transform         : lowercase;
  font-variant           : small-caps;
  text-indent            : .25em;
  padding                : .25em 0;
  background-color       : #d7d8cd;
}
div.saved-glosses dd {
  background-color       : #e8e9de;
  width                  : 96%;
  padding                : 2%;
  font-style             : italic;
  margin                 : 0;
  font-size              : .875em;
  line-height            : 1.25em;
}
~~~

`styles.css`

</div>

## Differentiated CSS in media query

~~~{.css}
@media all and (min-width: 50em) {
  /* ... */
  .saved-glosses {
    position  : relative;
  }
  .saved-glosses h3 {
    box-shadow: 0px 3px 3px #999;
  }
  .saved-glosses dl {
    width     : 28em;
    position  : absolute;
    top       : auto;
    box-shadow: 0px 3px 3px #999;
    z-index   : 500;
    left      : 0;
    border    : 1px solid #999;
    border-top: 0px;
  }
}
~~~

`styles.css`

## The styles make it look like this on a narrow screen

![](presenter-exercises/601-prototype/images/iphone.png)

![](presenter-exercises/601-prototype/images/iphone2.png)


## And like this on a wider screen

![](presenter-exercises/601-prototype/images/chrome.png)

![](presenter-exercises/601-prototype/images/chrome2.png)

* You can find the full working example of this first prototyped version in [presenter-exercises/601-prototype/](presenter-exercises/601-prototype)
* Let's [try it out](presenter-exercises/601-prototype/tempest.html)


## Progressive enhancement is holding

![Our page still works on a series-4 BlackBerry](presenter-exercises/601-prototype/images/8320.png)

# Part VII: It has to be faster

## Good, but not good enough

* Remember how I mentioned when we first implemented the Messi popups that they felt poky on older hardware?
* Let's watch a video of just how [poky this is on a Motorola Backflip (Android 1.5)](assets/videos/backflip-slow.MOV)

## Refactoring

* Problems
    * A lot of DOM elements being manipulated by JavaScript
    * A lot of complex CSS styling—opacity, gradients, transitions are all performance-costly
* Refactoring
    * I removed the Messi jQuery plugin and its styles
    * I updated my jQuery plugin so it didn't have dependencies on Messi
    * I created and styled my own popups
        * Didn't include code I wasn't using
        * Styling avoided use of too many processor-intensive CSS effects
        * *Did* retain a couple of gradients and a single `box-shadow`

## Another iteration of our saved-glosses code

* Re-factored code is in `presenter-exercises/602-prototype-improved`

### [Video: After the refactor](assets/videos/backflip-better.MOV)

### Real world moment

* Often stuff that looks great in our desktop world has to be wrestled with in the mobile reality to make it, as they say, *performant*.
* You'll note it still isn't slam-bam responsive on this old hardware. But it's about a 3-4x speed improvement.

## Also striking: BlackBerry 9670

* The BlackBerry 9670, despite being a new piece of hardware and a newer browser, is also super slow
* [Video: Before](assets/videos/9670-slow.MOV)
* [Video: After improvement](assets/videos/9670-better.MOV)

## Buttttt...

* The page still [loads and renders *incredibly slowly* on the 9670](assets/videos/9670-loading.MOV)
    * This is not about downloading the page assets; it is about the client-side rendering of the bits

### Beware!

Mobile optimization isn't all about page size and bandwidth. Parsing the DOM, renderig complex CSS-styled stuff, executing JS...all of this stuff can really add up on older phones.

## Some numbers

* Here's how long it took from resources received to an HTML page showing up at all (that is, the blank screen time between getting the resources and showing anything)

Resource(s)                                             Time
----------------                                        ---------
HTML page alone (DOM)                                   2 - 3.5sec
Stylesheet                                              .1sec
Modernizr.js                                            .5sec
jQuery                                                  1 - 2sec
Evaluation of Modernizr.mq()                            2.5sec
**TOTAL**                                               ~9sec

* A test page with a very simple DOM, jQuery and Modernizr, with the same `Modernizr.mq` query took about 2-3 seconds


## What is making this load so slowly on that BlackBerry?

* As you might expect, a combination of a bunch of key things:
    * Hardware
    * Browser
    * JavaScript handling in the browser
    * Overall page DOM complexity
    * Lack of caching
    * Number of HTTP requests
    * Large image to display

## Performance and the mobile web

* Minding your performance is step one on the mobile web
* Basic performance 101 is key, but often gets overlooked

## Top performance must-dos: Payload size

* Constrain payloads: reduce the number of bytes going over the network
    * **Turn on GZIP**
    * **I repeat, turn on GZIP**
    * Compress/minify scripts and CSS
    * Compress images
    * Serve optimized images from the server
    * Obsessively check your resource size using Web Inspector, [ySlow](http://developer.yahoo.com/yslow/) or similar tools

## Top performance must-dos: Minimize requests

* Keep HTTP requests to a minimum
    * Latency and round-trip time for requests over mobile networks is *higher* than terrestrial networks
    * Concurrent connections on mobile browsers are sometimes lower than desktop browsers
    * Concatenate scripts and JS files
    * Related: reduce DNS lookups
    * Fix yer 404s: Every request for something that doesn't exist is still a (useless) request
* Use, with caution:
    * CSS sprites
    * Data-URIs

## Top performance must-dos: Cache the hell out of it

* Good caching strategies help with both payload reduction and request reduction—the assets are already on the client
    * Set up far-future expires headers on the server
    * Be aware of caching size limits in older mobile browsers
    * Keep an eye on external resources (you don't control their caching)
    * Use, with caution
        * Assets can be stuffed in localStorage (CSS, JS, images as data-URIs)
        * ApplicationCache



## Let's tune this thing

* Compressing the big image
* Doing some quick, big-hit items on the server via an `.htaccess` file
    * Turning on gzip
    * Turning off eTags
    * Setting up far-future expires headers (for caching)
* Reduction of number of external resources
* Minification of JS and CSS; putting JS at the bottom of the page

### Further reading

* [Yahoo! Exceptional Performance Team](http://developer.yahoo.com/performance/)

## Performance tools

* [ySlow](http://developer.yahoo.com/yslow/)
* [smush.it](http://smush.it)
* [Online YUI Compressor for JS and CSS](http://refresh-sf.com/yui/)
* [Sample .htaccess file](presenter-exercises/603-performance/.htaccess)


## Before...

![Before tuning, ySlow stats](assets/images/performance-start.png)

## After...

![After tuning](assets/images/performance-end.png)

## Exercise: Advanced performance sleuthing

* How could the saved-glosses page be made even faster on mobile devices?

### [Exercise: Advanced sleuthing for performance items](exercises/701-advanced-performance)



# Part VIII: Making sure it works, a.k.a. Testing is Hell

## But what about testing all of this stuff?

### Some perspective

> If you think your web site works, you just haven’t tested enough. It is broken somewhere.
> —Lyza Gardner

### We can’t test everything

* No one tests every possible device and browser combination.
* Even on desktop, we don’t test every possible combination.
* So we have to make practical decisions about what we can reasonably test and develop sites in a way that minimizes potential issues.

## What does it mean to “support” a device?

* We think of support as coming in three tiers:
    * Devices and browsers that we explicitly support.
    * Devices and browsers that we don’t explicitly support, but that we expect to work in some fashion because we’ve built the site with best practices.
    * Devices and browsers we cannot support because they don’t meet a minimum bar for the application or site.
* The devices and browsers that we explicitly support are the ones we need to test on.

## Testing the mobile web is hard

* Not a lot of methodologies established
* There are, like, a billion different mobile devices and browsers
* Hardware required: $$$$ or ££££ or €€€€
* Remote debugging is still in its relative infancy

### OK, so, what do we do?

## Most of your testing is actually done on the desktop

* Before you get onto device (or even into emulator), most of your work prepping for testing on those devices is done in the "traditional" place of development: the desktop. 
* An area where we are more familiar and comfortable.
* Despite their many differences, desktop and mobile browsers do share a common core. You can make *some* assumptions about support before you get on-device.


## And you can set yourself up for increased likelihood of success

* Careful adherence to standards
* Techniques like modularized CSS for easier debug
* Clarity in your dev-test workflow

### Learning the art of un-testing

* The more mobile web things you build, the more you can anticipate trouble areas
* Likewise, you can also learn about dependable techniques

## A testing workflow

![Testing loops](assets/images/testing-loops.png)

* A key to successful testing is mapping out the points in your development cycle to insert device-specific testing.

## A testing workflow example

1. Initial foundation work on desktop
1. First set of testing across collection of test devices (broad)
1. Iteration + development cycles
1. Test on core devices
1. Repeat 3 and 4
1. Test across test devices (broad) on larger feature releases
1. Occasionally throw in a random device into test to keep yourself honest
1. Repeat 3 through 7


## The devices

![Devices...](assets/images/testing-devices.jpg)

* A smaller set of core devices: test on each iteration with these
* A larger set of supported devices: test every nth iteration
* Use common sense
* Keep a couple of easy-to-test devices within arm's reach

### Be ready to be caught by surprise

Some issues are hard to anticipate and arise from changes that seem innocuous. Recall:

* Opera Mini `line-height` issue
* BlackBerry OS 6 `small-caps` issues

## Set your foundation

* Foundational work of core of site or app on desktop
* After initial foundation is complete, broad test across your collection of supported devices and emulators
* Use version control and make discrete, incremental commits for easier rollback

## Iteration-and-test loop

* Small steps
* After each meaningful change (feature, CSS work, etc.) test on a selected subset of your supported devices
* Use your increasing experience to guide you what changes are most likely to cause on-device issues
* Whatever you do, do *not* make testing a single, end-of-project event. You will hate your life.
* At certain points, especially after significant change, test across your full collection of test devices
* Keep at least one of your older/lesser devices in your core group of test devices, even if it's not the biggest target device

## OK. What are the ways we can test the mobile web?

* Desktop-based testing
* On-device testing
* Remote debugging of physical devices
* Remote testing of remote devices
* Emulators

## Device testing is tedious and hard

* Fortunately, there are some tools:
  * **[Adobe Shadow](http://labs.adobe.com/technologies/shadow/)** (iOS, Android): Remote webkit debug with weinre and shim features, made a lot more user friendly (free)
  * **[weinre](http://people.apache.org/~pmuellr/weinre/docs/1.x/1.5.0/)**: Patrick Mueller's original remote debug for webkit on mobile
  * **[shim](https://github.com/marstall/shim)**: Synced web surfing across connected browsers (node.js)
  * **[Opera Dragonfly](http://www.opera.com/dragonfly/)**: Remote testing (and more) for Opera
  * **[FireFox mobile remote debug (NEW!)](http://starkravingfinkle.org/blog/2012/08/firefox-for-android-remote-debugging-is-here/)**: Several-step setup; I can't get it to work just yet.

## Adobe Shadow

![Devices being tested with Adobe Shadow](assets/images/shadow.jpg)


## MOAR testing tools

* [User agent switcher](https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/)
* [User agent switcher config file](http://techpatterns.com/forums/about304.html)
* [Resizer](https://chrome.google.com/webstore/detail/kkelicaakdanhinjdeammmilcgefonfh) / [Web Developer Toolkit](http://chrispederick.com/work/web-developer/)
* [Blaze.io Mobile Test](http://blaze.io/mobile)
* Automated testing foundations: Web drivers for specs can use headless Mozilla or Webkit, resize the browser, take automated screenshots, etc.
* [ResponsivePX](http://responsivepx.com/)
* [Mobile Performance Bookmarklets](http://stevesouders.com/mobileperf/mobileperfbkm.php)
* [jDrop](http://jdrop.org/)

## Other things

* Emulators
    * Generally available in various platform SDKs
    * Some web-based emulators
    * Try to get hardware when you can
    * Can be useful for testing really legacy devices, e.g.
        * [N70 Emulator](http://emulator.mtld.mobi/emulator.php?emulator=nokiaN70)
    * Opera Mini older versions can be found in emulators online
* Misc.
    * [debug.phonegap.com](http://debug.phonegap.com): Free, online weinre
    * (Truly) remote device testing: [Device Anywhere](http://www.keynotedeviceanywhere.com/) and [Perfecto Mobile](http://www.perfectomobile.com/)

## Building a device collection

![Cloud Four's device library](assets/images/cloudfour-testing.jpg)

## What devices to get

* A "modern" iOS device. iPads are obviously a different form factor than iPhones, but having just one of the two covers a lot of bases.
* A "modern" Android device running Ice Cream Sandwich (OS 4) or at least Gingerbread (2.3).
    * Preferably a "commodity" device—that is, not the fastest, greatest, but the most likely to be given away free at operator/carrier stores.
* A slightly older Android running 2.0-2.2.
* A modern BlackBerry (OS 6, 7 or newer).
* An older BlackBerry (OS 5).

## What devices to get, cont'd.

* Are you in Europe? A Symbian Nokia phone.
* If your organization focuses on a demographic heavy on BlackBerrys, consider an old BlackBerry running OS 4.
* A "modern" Windows phone. The Nokia N8 and N9 are very nice devices.
* An old Android running <2.
* A device (BlackBerry has many) with an unusual aspect ratio.
* A larger-format Android device that is not a tablet, e.g. Samsung Note

## Tablets

* iPad
* Kindle Fire
* Android tablet
* BlackBerry PlayBook
* Windows 8 tablet (coming soon)

## Tactics for acquiring devices

* Add your own devices to your testing library as your replace them with newer ones. Having out-of-date devices is actually a huge boon.
* Factor in the cost of a device or two in projects focusing on those devices.
* Join developer programs at different device manufacturers. These are generally not free. BlackBerry has a well-established one. Nokia has a developer relations program as well.
* Buy devices used online (Craiglist is a great source in the U.S.; eBay is decent, too). Some can be quite cheap.
* Buying devices in the US can save money. But be very aware that the vast majority of these devices are "locked" to carrier.
* Talk to device manufacturers and mobile companies directly. It's surprising how often they're quite keen to help.
* Go to events and conferences and hope. Lots of mobile conferences give away (often many) devices as door prizes. Heck, I won a BlackBerry torch that way. If you can go to Google I/O you may well walk away with four or five devices (Cloud Four co-founder Jason did, recently).

## The biggest tips for device libraries

* **TEAM UP**: Connect with other developers and organizations through local user groups and the like. Chat. Swap. Trade. 
* **MAKE IT EASY FOR YOURSELF**: Make it easier to test on device and you'll do it more.

### A few resources

* [BagCheck Device Testing Gear](https://bagcheck.com/blog/22-mobile-device-testing-the-gear)
* [BBC Devices](http://mobiletestingfordummies.tumblr.com/post/20056227958/testing)


## Efficiencies

* Define a spot for your devices. A bookshelf, table or desk for them to live on or in.
* Keep as many devices charged as is reasonably possible.
* Group devices by charger and platform.
* Have a plan for system and software updates.
* Have a work area at or near the testing library.
* Keep in mind the overhead required for device maintenance when establishing a collection.
* If you're the organized type, create a spreadsheet or somesuch for tracking the details of your devices.
* Don't collect *too* many devices.

## Weird things you might not think of when choosing test devices

When choosing a device within a given platform, consider:

* Which has the better keyboard (soft or hard)? You'll be entering in URLs willy-nilly, and variations in keyboard layouts and tactile feedback across devices can make a big difference.
* How easy is it to find and change Wifi settings? Any other Wifi issues?
* Battery life when idle/hibernating. Phones that don't need to be charged constantly when not in use are a boon to device libraries.
* Charging interface. Aim for USB mini (becoming more universal these days but there are still outliers, esp. iOS and tablets).
* How easy is it to update the OS and/or apps? Some of this is carrier/operator dependent.

## Some emerging techniques

* Something I've done lately when doing Rails development is use the combination of:
    * rSpec/Capybara
    * poltergeist: Phantom.js Web driver for Capybara tests
    * jasmine for JS testing
* [jQueryMobile Automated Selenium Testing](http://www.youtube.com/watch?v=51E3FWMKkig&feature=player_embedded#!)
* The emergence of automated remote testing

## More new stuff

![AppThwack (Closed Beta) automated Android web screen shots](assets/images/appthwack.png)

* [Screen grab of entire page of Android results](assets/images/appthwack-full.png)

## Case study: testing the Tempest project

* Full test suite
    * iPhone iOS 5 Safari
    * iPhone iOS 5 Opera Mini
    * Android Nexus S 4.0
    * Android Nexus S 4.0 Firefox 15
    * BlackBerry 9670 (OS 6)
    * BlackBerry 8230 (OS 4.5)
    * Motorola Backflip Android 1.5
    * Kindle Fire
    * Nokia N8 Windows Phone 7.5

## Case study: testing the Tempest

* Extended test suite
    * iPhone Nexus 1 Android 2.3
    * BlackBerry PlayBook
    * iPad iOS5 (first-generation)
    * Samsung Galaxy S (Android 2.2)
    * Google G1 (Android 1.6)
    * BlackBerry 9800 Torch (OS 6)
    * BlackBerry 9810 Torch (OS 6)


## Case study: testing the Tempest scene

* Foundational HTML only
    * Test across full suite
    * Take note of title adjustment needs
* Baseline CSS
    * Full suite test
    * Noted a bug in my CSS (font stack)
* Fluid baseline CSS
    * Full suite test
    * Found box-model bug in my CSS
    * Found `small-caps` issue on multiple BlackBerrys
        * Testing on extended set of BlackBerrys

## Case study: testing the Tempest scene, cont.

* Media queries
    * Restricted suite testing (fairly confident/un-testing)
    * IE desktop testing (based on knowledge of fail)
    * Shimmed HTML5
* `@font-face` enhancement
    * Restricted suite testing
    * Additional BlackBerry testing (wary after `small-caps`)
    * Found BlackBerry hell
        * Decided to put `@font-face` in media query

## Case study: testing the Tempest scene, cont.

* Line-number enhancement
    * Restricted suite testing
* HTML markup for glossary
    * Restricted suite testing
    * Extended testing on tablets for `css-column`
* Messi jQuery plugin
    * Immediate fail on mobile
* Messi CSS refactor/prototype save button
    * Full suite test
    * Found Opera Mini `line-height` issue

## Case study: testing the Tempest scene, cont.

* Prototyped functionality of gloss-save feature
    * Not covered in slides (proof of concept stage)
    * Multiple full-suite tests
* Revised, first version gloss-save feature (CSS and JS)
    * Full suite test
* Non-Messi popup version for performance
    * Full suite test with emphasis on older devices
* Performance enhancements
    * Restricted suite testing
* Complete
    * Extended suite testing





[adactio]: http://adactio.com/journal
[adactio-content-first]: http://adactio.com/journal/4523/
[aea-oct-12]: http://aneventapart.com/2011/dc/
[cssweekly]: http://css-weekly.com
[cut-crap]: https://speakerdeck.com/u/lyzadanger/p/cutting-through-the-crap-the-essence-of-content-on-the-future-web
[hfmw]: http://bit.ly/hf-mw
[history-markup]: http://www.youtube.com/watch?v=egKQhGLomcQ
[lukew]: http://www.lukew.com/
[lukew-aea-content-first]: http://www.lukew.com/ff/entry.asp?1430
[mcgrane]: http://karenmcgrane.com/
[mobilism]: http://mobilism.nl
[opera-mini-simulator]: http://www.opera.com/developer/tools/mini/
[rahn-frederick]: http://www.amazon.com/Beginning-Smartphone-Web-Development-Applications/dp/143022620X
[stephenhay-structured-content]: http://www.slideshare.net/stephenhay/structured-content-first
[w3c-validator]: http://validator.w3c.org
